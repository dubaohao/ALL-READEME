# 2018 大厂高级前端面试题汇总

面试的公司分别是：

阿里、网易、滴滴、今日头条、有赞、挖财、沪江、饿了么、携程、喜马拉雅、兑吧、微医、寺库、宝宝树、海康威视、蘑菇街、酷家乐、百分点和海风教育

## 阿里

### 使用过的koa2中间件

- koa-router【路由】
- glob【一个规则，允许使用*等符号匹配对应规则的文件】
- koa-view【视图模板渲染】
- koa-bodyparser/koa-body【Request Body的解析器】
- koa-session【HTTP是无状态协议，为了保持用户状态，我们一般使用Session会话，koa-session提供了这样的功能，既支持将会话信息存储在本地Cookie，也支持存储在如Redis, MongoDB这样的外部存储设备。】
- koa-jwt【随着网站前后端分离方案的流行，越来越多的网站从Session Base转为使用Token Base，JWT(Json Web Tokens)作为一个开放的标准被很多网站采用，koa-jwt这个中间件使用JWT认证HTTP请求。】
- koa-helmet【网络安全得到越来越多的重视，[helmet](https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fhelmetjs%2Fhelmet) 通过增加如Strict-Transport-Security, X-Frame-Options, X-Frame-Options等HTTP头提高Express应用程序的安全性，koa-helmet为koa程序提供了类似的功能，参考[Node.js安全清单](https://link.jianshu.com?t=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000003860400)。】
- koa-cpmpress【当响应体比较大时，我们一般会启用类似Gzip的压缩技术减少传输内容，koa-compress提供了这样的功能，可根据需要进行灵活的配置。】
- koa-logger【koa-logger提供了输出请求日志的功能，包括请求的url、状态码、响应时间、响应体大小等信息，对于调试和跟踪应用程序特别有帮助，[koa-bunyan-logger](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fkoajs%2Fbunyan-logger) 提供了更丰富的功能。】
- koa-convert【对于比较老的使用Generate函数的koa中间件(< koa2)，官方提供了一个灵活的工具可以将他们转为基于Promise的中间件供Koa2使用，同样也可以将新的基于Promise的中间件转为旧式的Generate中间件。】
- koa-static【Node.js除了处理动态请求，也可以用作类似Nginx的静态文件服务，在本地开发时特别方便，可用于加载前端文件或后端Fake数据，可结合 [koa-compress](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fkoajs%2Fcompress) 和 [koa-mount](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fkoajs%2Fmount) 使用。】

### 中间件工作原理

- 初始化koa实例后，我们会用`use`方法来加载中间件(middleware)，会有一个数组来存储中间件，use调用顺序会决定中间件的执行顺序。

- 每个中间件都是一个函数(不是函数将报错)，接收两个参数，**第一个是ctx上下文对象，另一个是next函数(由koa-compose定义)**

  **原理**就是：

  会从middleware数组中取第一个函数开始执行，中间件函数中**调用next方法就会去取下一个中间件函数继续执行**。每个中间件函数执行完毕后都会返回一个**promise对象**。(ps:调用next方法并不是表示当前中间件函数执行完毕了，调用next之后仍可以继续执行其他代码)

  ![洋葱图](F:\Code\github\前端面试\assets\6383319-09c1061cf194e0b8.webp)

### koa-body原理

**首先，介绍前置知识**

HTTP报文主要分为请求报文和响应报文，koa-bodyparser主要针对请求报文的处理。

请求报文主要由以下三个部分组成：

- 报文头部
- 空行
- 报文主体

而koa-bodyparser中的body指的就是请求报文中的报文主体部分。

HTTP底层采用TCP提供可靠的字节流服务，简单而言就是报文主体部分会被转化为二进制数据在网络中传输，所以服务器端首先需要拿到二进制流数据。

谈到网络传输，当然会涉及到传输速度的优化，而其中一种优化方式就是对内容进行压缩编码，常用的压缩编码方式有：

- gzip
- compress
- deflate
- identity（不执行压缩或不会变化的默认编码格式）

服务器端会根据报文头部信息中的Content-Encoding确认采用何种解压编码。

  接下来就需要将二进制数据转换为相应的字符，而字符也有不同的字符编码方式，例如对于中文字符处理差异巨大的UTF-8和GBK，UTF-8编码汉字通常需要三个字节，而GBK只需要两个字节。所以还需要在请求报文的头部信息中设置Content-Type使用的字符编码信息（默认情况下采用的是UTF-8），这样服务器端就可以利用相应的字符规则进行解码，得到正确的字符串。

  拿到字符串之后，服务器端又要问了：客户端，你这一段字符串是啥意思啊？

  根据不同的应用场景，客户端会对字符串采用不同的编码方式，常见的编码方式有：

- URL编码方式: a=1&b=2
- JSON编码方式: {a:1,b:2}

客户端会将采用的字符串编码方式设置在请求报文头部信息的Content-Type属性中，这样服务器端根据相应的字符串编码规则进行解码，就能够明白客户端所传递的信息了。

**重点**

- 获取二进制数据流

> Node.js 获取报文主体二进制数据，主要通过监听request对象的data。【而koa-bodyparser主要是对[co-body](https://github.com/cojs/co-body)的封装，而【co-body】中主要是采用[raw-body](https://github.com/stream-utils/raw-body)模块获取请求报文主体的二进制数据流，【row-body】主要是对上述示例代码的封装和健壮性处理。】

- 内容解码

> 客户端会将内容编码的方式放入请求报文头部信息Content-Encoding属性中，服务器端接收报文主体的二进制数据了时，会根据该头部信息进行解压操作，当然服务器端可以在响应报文头部信息Accept-Encoding属性中添加支持的解压方式。
>
> 而【row-body】主要采用inflation模块进行解压处理。

- 字符解码

> 一般而言，UTF-8是互联网中主流的字符编码方式，前面也提到了还有GBK编码方式，相比较UTF-8，它编码中文只需要2个字节，那么在字符解码时误用UTF-8解码GBK编码的字符，就会出现中文乱码的问题。
>
> NodeJS主要通过Buffer处理二进制数据流，但是它并不支持GBK字符编码方式，需要通过iconv-lite模块进行处理。

- 字符串解码

> 前面已经提到了字符串的二种编码方式，它们对应的Content-Type分别为：
>
> 1. URL编码 application/x-www-form-urlencoded
> 2. JSON编码 application/json
>
> 对于前端来说，URL编码并不陌生，经常会用于URL拼接操作，唯一需要注意的是不要忘记对键值对进行decodeURIComponent()处理。
>
> 当客户端发送请求主体时，需要进行编码操作：
>
> > 'a=1&b=2&c=3'
>
> 服务器端再根据URL编码规则解码，得到相应的对象。
>
> ```
> // URL编码方式 简单的解码方法实现
> function decode (qs, sep = '&', eq = '=') {
> const obj = {}
> qs = qs.split(sep)
> 
> for (let i = 0, max = qs.length; i < max; i++) {
>  const item = qs[i]
>  const index = item.indexOf(eq)
> 
> let key, value
> 
> if (~index) {
> key = item.substr(0, index)
> value = item.substr(index + 1)
> } else {
> key = item
> value = ''
> }
> 
> key = decodeURIComponent(key)
> value = decodeURIComponent(value)
> 
> if (!obj.hasOwnProperty(key)) {
> obj[key] = value
> }
> 
> }
> return obj
> }
> 
> console.log(decode('a=1&b=2&c=3')) // { a: '1', b: '2', c: '3' }
> ```
>
> URL编码方式适合处理简单的键值对数据，并且很多框架的Ajax中的Content-Type默认值都是它，但是对于复杂的嵌套对象就不太好处理了，这时就需要JSON编码方式大显身手了。
>
> 客户端发送请求主体时，只需要采用JSON.stringify进行编码。服务器端只需要采用JSON.parse进行解码即可：
>
> ```
> const strictJSONReg = /^[\x20\x09\x0a\x0d]*(\[|\{)/;
> function parse(str) {
> if (!strict) return str ? JSON.parse(str) : str;
> // 严格模式下，总是返回一个对象
> if (!str) return {};
> // 是否为合法的JSON字符串
> if (!strictJSONReg.test(str)) {
>  throw new Error('invalid JSON, only supports object and array');
> }
> return JSON.parse(str);
> 
> }
> ```
>
> 除了上述两种字符串编码方式，koa-bodyparser还支持不采用任何字符串编码方式的普通字符串。
>
> 三种字符串编码的处理方式由【co-body】模块提供，koa-bodyparser中通过判断当前Content-Type类型，调用不同的处理方式，将获取到的结果挂载在ctx.request.body：
>
> ```
> return async function bodyParser(ctx, next) {
>  if (ctx.request.body !== undefined) return await next();
>  if (ctx.disableBodyParser) return await next();
>  try {
>    // 最重要的一步 将解析的内容挂载到koa的上下文中
>    const res = await parseBody(ctx);
>    ctx.request.body = 'parsed' in res ? res.parsed : {};
>    if (ctx.request.rawBody === undefined) ctx.request.rawBody = res.raw; // 保存原始字符串
>  } catch (err) {
>    if (onerror) {
>      onerror(err, ctx);
>    } else {
>      throw err;
>    }
>  }
>  await next();
> };
> 
> async function parseBody(ctx) {
>  if (enableJson && ((detectJSON && detectJSON(ctx)) || ctx.request.is(jsonTypes))) {
>    return await parse.json(ctx, jsonOpts); // application/json等json type
>  }
>  if (enableForm && ctx.request.is(formTypes)) {
>    return await parse.form(ctx, formOpts); // application/x-www-form-urlencoded
>  }
>  if (enableText && ctx.request.is(textTypes)) {
>    return await parse.text(ctx, textOpts) || ''; // text/plain
>  }
>  return {};
> }
> 
> };
> ```
>
> 其实还有一种比较常见的Content-type，当采用表单上传时，报文主体中会包含多个实体主体：
>
> ```
> ------WebKitFormBoundaryqsAGMB6Us6F7s3SF
> Content-Disposition: form-data; name="image"; filename="image.png"
> Content-Type: image/png
> 
> ------WebKitFormBoundaryqsAGMB6Us6F7s3SF
> Content-Disposition: form-data; name="text"
> 
> ------WebKitFormBoundaryqsAGMB6Us6F7s3SF--
> ```
>
> 这种方式处理相对比较复杂，koa-bodyparser中并没有提供该Content-Type的解析。

![图解http](F:\Code\github\前端面试\assets\16851d10d3942128)



### 介绍自己写过的中间件

??????

### 有没有涉及到Cluster

HTTP服务器用于响应来自客户端的请求，当客户端请求数逐渐增大时服务端的处理机制有多种，如tomcat的多线程、nginx的事件循环等。而对于node而言，由于其也采用事件循环和异步I/O机制，因此在高I/O并发的场景下性能非常好，但是由于单个node程序仅仅利用单核cpu，因此为了更好利用系统资源就需要fork多个node进程执行HTTP服务器逻辑，所以node内建模块提供了**child_process和cluster**模块。

利用child_process模块，我们可以执行shell命令，可以fork子进程执行代码，也可以直接执行二进制文件；

利用cluster模块，使用node封装好的API、IPC通道和调度机可以非常简单的创建包括`一个master进程下HTTP代理服务器 + 多个worker进程多个HTTP应用服务器`的架构，并提供两种调度子进程算法。

本文主要针对cluster模块讲述node是如何实现简介高效的服务集群创建和调度的。那么就从代码进入本文的主题：

**code1**

```
const cluster = require('cluster');
const http = require('http');

if (cluster.isMaster) {
  let numReqs = 0;
  setInterval(() => {
    console.log(`numReqs = ${numReqs}`);
  }, 1000);

  function messageHandler(msg) {
    if (msg.cmd && msg.cmd === 'notifyRequest') {
      numReqs += 1;
    }
  }
  const numCPUs = require('os').cpus().length;
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  for (const id in cluster.workers) {
    cluster.workers[id].on('message', messageHandler);
  }

} else {

  // Worker processes have a http server.
  http.Server((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
    process.send({ cmd: 'notifyRequest' });
  }).listen(8000);
}
```

主进程创建多个子进程

主进程创建多个子进程，同时接受子进程传来的消息，循环输出处理请求的数量；

子进程创建http服务器，侦听8000端口并返回响应。

泛泛的大道理谁都了解，可是这套代码如何运行在主进程和子进程中呢？父进程如何向子进程传递客户端的请求？多个子进程共同侦听8000端口，会不会造成端口reuse error？每个服务器进程最大可有效支持多少并发量？主进程下的代理服务器如何调度请求？ 这些问题，如果不深入进去便永远只停留在写应用代码的层面，而且不了解cluster集群创建的多进程与使用child_process创建的进程集群的区别，也写不出符合业务的最优代码，因此，深入cluster还是有必要的。

#### cluster与net

cluster模块与net模块息息相关，而net模块又和底层socket有联系，至于socket则涉及到了系统内核，这样便由表及里的了解了node对底层的一些优化配置，这是我们的思路。介绍前，笔者仔细研读了node的js层模块实现，在基于自身理解的基础上诠释上节代码的实现流程，力图做到清晰、易懂，如果有某些纰漏也欢迎读者指出，只有在互相交流中才能收获更多。

**一套代码，多次执行**

很多人对**code1**代码如何在主进程和子进程执行感到疑惑，怎样通过*cluster.isMaster*判断语句内的代码是在主进程执行，而其他代码在子进程执行呢？

其实只要你深入到了node源码层面，这个问题很容易作答。cluster模块的代码只有一句：

```
module.exports = ('NODE_UNIQUE_ID' in process.env) ?
                require('internal/cluster/child') :
                require('internal/cluster/master');
```

只需要判断当前进程有没有环境变量“NODE_UNIQUE_ID”就可知道当前进程是否是主进程；而变量“NODE_UNIQUE_ID”则是在主进程fork子进程时传递进去的参数，因此采用cluster.fork创建的子进程是一定包含“NODE_UNIQUE_ID”的。

**这里需要指出的是，必须通过cluster.fork创建的子进程才有NODE_UNIQUE_ID变量，如果通过child_process.fork的子进程，在不传递环境变量的情况下是没有NODE_UNIQUE_ID的。因此，当你在child_process.fork的子进程中执行cluster.isMaster判断时，返回 true。**

**主进程和服务器**

**code1**中，并没有在cluster.isMaster的条件语句中创建服务器，也没有提供服务器相关的路径、端口和fd，那么主进程中是否存在TCP服务器，有的话到底是什么时候怎么创建的？

相信大家在学习nodejs时阅读的各种书籍都介绍过在集群模式下，主进程的服务器会接受到请求然后发送给子进程，那么问题就来到主进程的服务器到底是如何创建呢？主进程服务器的创建离不开与子进程的交互，毕竟与创建服务器相关的信息全在子进程的代码中。

当子进程执行时，http模块会调用net模块(确切的说，http.Server继承net.Server)，创建net.Server对象，同时侦听端口。创建net.Server实例，调用构造函数返回。创建的net.Server实例调用listen(8000)，等待accpet连接。那么，子进程如何传递服务器相关信息给主进程呢？答案就在listen函数中。我保证，net.Server.prototype.listen函数绝没有表面上看起来的那么简单，它涉及到了许多IPC通信和兼容性处理，可以说HTTP服务器创建的所有逻辑都在listen函数中。

```
http.Server((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
    process.send({ cmd: 'notifyRequest' });
  }).listen(8000);
```

> 延伸下，在学习linux下的socket编程时，服务端的逻辑依次是执行`socket(),bind(),listen()和accept()`，在接收到客户端连接时执行`read(),write()`调用完成TCP层的通信。那么，对应到node的net模块好像只有**listen()**阶段，这是不是很难对应socket的四个阶段呢？其实不然，node的net模块把“bind，listen”操作全部写入了net.Server.prototype.listen中，清晰的对应底层socket和TCP三次握手，而向上层使用者只暴露简单的listen接口。

**code2**

```
Server.prototype.listen = function() {

  ...

  // 根据参数创建 handle句柄
  options = options._handle || options.handle || options;
  // (handle[, backlog][, cb]) where handle is an object with a handle
  if (options instanceof TCP) {
    this._handle = options;
    this[async_id_symbol] = this._handle.getAsyncId();
    listenInCluster(this, null, -1, -1, backlogFromArgs);
    return this;
  }
  ...
  var backlog;
  if (typeof options.port === 'number' || typeof options.port === 'string') {
    if (!isLegalPort(options.port)) {
      throw new RangeError('"port" argument must be >= 0 and < 65536');
    }
    backlog = options.backlog || backlogFromArgs;
    // start TCP server listening on host:port
    if (options.host) {
      lookupAndListen(this, options.port | 0, options.host, backlog,
              options.exclusive);

    } else { // Undefined host, listens on unspecified address
      // Default addressType 4 will be used to search for master server
      listenInCluster(this, null, options.port | 0, 4,
                      backlog, undefined, options.exclusive);
    }
    return this;
  }
  ...
  throw new Error('Invalid listen argument: ' + util.inspect(options));
};
```

由于本文只探究cluster模式下HTTP服务器的相关内容，因此我们只关注有关TCP服务器部分，其他的Pipe（domain socket）服务不考虑。

listen函数可以侦听端口、路径和指定的fd，因此在listen函数的实现中判断各种参数的情况，我们最为关心的就是侦听端口的情况，在成功进入条件语句后发现所有的情况最后都执行了listenInCluster函数而返回，因此有必要继续探究。

**code3**

```
function listenInCluster(server, address, port, addressType,
                         backlog, fd, exclusive) {.
  if (cluster.isMaster || exclusive) {
    server._listen2(address, port, addressType, backlog, fd);
    return;
  }
  // 后续代码为worker执行逻辑
  const serverQuery = {
    address: address,
    port: port,
    addressType: addressType,
    fd: fd,
    flags: 0
  };
  ... 
  cluster._getServer(server, serverQuery, listenOnMasterHandle);
}
```

listenInCluster函数传入了各种参数，如server实例、ip、port、ip类型（IPv6和IPv4）、backlog（底层服务端socket处理请求的最大队列）、fd等，它们不是必须传入，比如创建一个TCP服务器，就仅仅需要一个port即可。

简化后的listenInCluster函数很简单，cluster模块判断当前进程为主进程时，执行_listen2函数；否则，在子进程中执行cluster._getServer函数，同时像函数传递serverQuery对象，即创建服务器需要的相关信息。

因此，我们可以大胆假设，子进程在cluster._getServer函数中向主进程发送了创建服务器所需要的数据，即serverQuery。实际上也确实如此：

**code4**

```
cluster._getServer = function(obj, options, cb) {
  const message = util._extend({
    act: 'queryServer',
    index: indexes[indexesKey],
    data: null
  }, options);
  send(message, function modifyHandle(reply, handle) => {
    if (typeof obj._setServerData === 'function')
      obj._setServerData(reply.data);
    if (handle)
      shared(reply, handle, indexesKey, cb);  // Shared listen socket.
    else
      rr(reply, indexesKey, cb);              // Round-robin.
  });
};
```

子进程在该函数中向已建立的IPC通道发送内部消息message，该消息包含之前提到的serverQuery信息，同时包含**act: 'queryServer'**字段，等待服务端响应后继续执行回调函数modifyHandle。

主进程接收到子进程发送的内部消息，会根据**act: 'queryServer'**执行对应queryServer方法，完成服务器的创建，同时发送回复消息给子进程，子进程执行回调函数modifyHandle，继续接下来的操作。

至此，针对主进程在cluster模式下如何创建服务器的流程已完全走通，主要的逻辑是在子进程服务器的listen过程中实现。

**net模块与socket**

上节提到了node中创建服务器无法与socket创建对应的问题，本节就该问题做进一步解释。在net.Server.prototype.listen函数中调用了listenInCluster函数，listenInCluster会在主进程或者子进程的回调函数中调用_listen2函数，对应底层服务端socket建立阶段的正是在这里。

```
function setupListenHandle(address, port, addressType, backlog, fd) {
  // worker进程中，_handle为fake对象，无需创建
  if (this._handle) {
    debug('setupListenHandle: have a handle already');
  } else {
    debug('setupListenHandle: create a handle');
    if (rval === null)
      rval = createServerHandle(address, port, addressType, fd);
    this._handle = rval;
  }
  this[async_id_symbol] = getNewAsyncId(this._handle);
  this._handle.onconnection = onconnection;
  var err = this._handle.listen(backlog || 511);
}
```

通过createServerHandle函数创建句柄（句柄可理解为用户空间的socket），同时给属性onconnection赋值，最后侦听端口，设定backlog。

那么，socket处理请求过程“socket(),bind()”步骤就是在createServerHandle完成。

```
function createServerHandle(address, port, addressType, fd) {
  var handle;
  // 针对网络连接，绑定地址
  if (address || port || isTCP) {
    if (!address) {
      err = handle.bind6('::', port);
      if (err) {
        handle.close();
        return createServerHandle('0.0.0.0', port);
      }
    } else if (addressType === 6) {
      err = handle.bind6(address, port);
    } else {
      err = handle.bind(address, port);
    }
  }
  return handle;
}
```

在createServerHandle中，我们看到了如何创建socket（createServerHandle在底层利用node自己封装的类库创建TCP handle），也看到了bind绑定ip和地址，那么node的net模块如何接收客户端请求呢？

必须深入c++模块才能了解node是如何实现在c++层面调用js层设置的onconnection回调属性，v8引擎提供了c++和js层的类型转换和接口透出，在c++的tcp_wrap中：

```
void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int backloxxg = args[0]->Int32Value();
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}
```

我们关注uv_listen函数，它是libuv封装后的函数，传入了**handle_,backlog和OnConnection回调函数**，其中handle_为node调用libuv接口创建的socket封装，OnConnection函数为socket接收客户端连接时执行的操作。我们可能会猜测在js层设置的onconnction函数最终会在OnConnection中调用，于是进一步深入探查node的connection_wrap c++模块：

```
template <typename WrapType, typename UVType>
void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle,int status) {
  if (status == 0) {
    if (uv_accept(handle, client_handle))
      return;
    // Successful accept. Call the onconnection callback in JavaScript land.
    argv[1] = client_obj;
  }
  wrap_data->MakeCallback(env->onconnection_string(), arraysize(argv), argv);
}
```

过滤掉多余信息便于分析。当新的客户端连接到来时，libuv调用OnConnection，在该函数内执行uv_accept接收连接，最后将js层的回调函数onconnection[通过env->onconnection_string()获取js的回调]和接收到的客户端socket封装传入MakeCallback中。其中，argv数组的第一项为错误信息，第二项为已连接的clientSocket封装，最后在MakeCallback中执行js层的onconnection函数，该函数的参数正是argv数组传入的数据，“错误代码和clientSocket封装”。

**js层的onconnection回调**

```
function onconnection(err, clientHandle) {
  var handle = this;
  if (err) {
    self.emit('error', errnoException(err, 'accept'));
    return;
  }
  var socket = new Socket({
    handle: clientHandle,
    allowHalfOpen: self.allowHalfOpen,
    pauseOnCreate: self.pauseOnConnect
  });
  socket.readable = socket.writable = true;
  self.emit('connection', socket);
}
```

这样，node在C++层调用js层的onconnection函数，构建node层的socket对象，并触发connection事件，完成底层socket与node net模块的连接与请求打通。

至此，我们打通了socket连接建立过程与net模块（js层）的流程的交互，这种封装让开发者在不需要查阅底层接口和数据结构的情况下，仅使用node提供的http模块就可以快速开发一个应用服务器，将目光聚集在业务逻辑中。

> backlog是已连接但未进行accept处理的socket队列大小。在linux 2.2以前，backlog大小包括了半连接状态和全连接状态两种队列大小。linux 2.2以后，分离为两个backlog来分别限制半连接SYN_RCVD状态的未完成连接队列大小跟全连接ESTABLISHED状态的已完成连接队列大小。这里的半连接状态，即在三次握手中，服务端接收到客户端SYN报文后并发送SYN+ACK报文后的状态，此时服务端等待客户端的ACK，全连接状态即服务端和客户端完成三次握手后的状态。backlog并非越大越好，当等待accept队列过长，服务端无法及时处理排队的socket，会造成客户端或者前端服务器如nignx的连接超时错误，出现**“error: Broken Pipe”**。因此，node默认在socket层设置backlog默认值为511，这是因为nginx和redis默认设置的backlog值也为此，尽量避免上述错误。

**多个子进程与端口复用**

再回到关于cluster模块的主线中来。code1中，主进程与所有子进程通过消息构建出侦听8000端口的TCP服务器，那么子进程中有没有也创建一个服务器，同时侦听8000端口呢？其实，在子进程中压根就没有这回事，如何理解呢？子进程中确实创建了net.Server对象，可是它没有像主进程那样在libuv层构建socket句柄，子进程的net.Server对象使用的是一个人为fake出的一个假句柄来“欺骗”使用者端口已侦听，这样做的目的是为了集群的负载均衡，这又涉及到了cluster模块的均衡策略的话题上。

在本节有关cluster集群端口侦听以及请求处理的描述，都是基于cluster模式的默认策略RoundRobin之上讨论的，关于调度策略的讨论，我们放在下节进行。

在**主进程与服务器**这一章节最后，我们只了解到主进程是如何创建侦听给定端口的TCP服务器的，此时子进程还在等待主进程创建后发送的消息。当主进程发送创建服务器成功的消息后，子进程会执行modifyHandle回调函数。还记得这个函数吗？**主进程与服务器**这一章节最后已经贴出来它的源码：

```
function modifyHandle(reply, handle) => {
    if (typeof obj._setServerData === 'function')
      obj._setServerData(reply.data);
    if (handle)
      shared(reply, handle, indexesKey, cb);  // Shared listen socket.
    else
      rr(reply, indexesKey, cb);              // Round-robin.
  }
```

它会根据主进程是否返回handle句柄（即libuv对socket的封装）来选择执行函数。由于cluter默认采用RoundRobin调度策略，因此主进程返回的handle为null，执行函数rr。在该函数中，做了上文提到的hack操作，作者fake了一个假的handle对象，“欺骗”上层调用者：

```
function listen(backlog) {
    return 0;
  }
  const handle = { close, listen, ref: noop, unref: noop };
  handles[key] = handle;
  cb(0, handle);
```

看到了吗？fake出的handle.listen并没有调用libuv层的Listen方法，它直接返回了。这意味着什么？？子进程压根没有创建底层的服务端socket做侦听，所以在子进程创建的HTTP服务器侦听的端口根本不会出现端口复用的情况。 最后，调用cb函数，将fake后的handle传递给上层net.Server，设置net.Server对底层的socket的引用。此后，子进程利用fake后的handle做端口侦听（其实压根啥都没有做），执行成功后返回。

那么子进程TCP服务器没有创建底层socket，如何接受请求和发送响应呢？这就要依赖IPC通道了。既然主进程负责接受客户端请求，那么理所应当由主进程分发客户端请求给某个子进程，由子进程处理请求。实际上也确实是这样做的，主进程的服务器中会创建RoundRobinHandle决定分发请求给哪一个子进程，筛选出子进程后发送newconn消息给对应子进程：

```
  const message = { act: 'newconn', key: this.key };
  sendHelper(worker.process, message, handle, (reply) => {
    if (reply.accepted)
      handle.close();
    else
      this.distribute(0, handle);  // Worker is shutting down. Send to another.
    this.handoff(worker);
  });
```

子进程接收到newconn消息后，会调用内部的onconnection函数，先向主进程发送开始处理请求的消息，然后执行业务处理函数handle.onconnection。还记得这个handle.onconnection吗？它正是上节提到的node在c++层执行的js层回调函数，在handle.onconnection中构造了net.Socket对象标识已连接的socket，最后触发connection事件调用开发者的业务处理函数（此时的数据处理对应在网络模型的第四层传输层中，node的http模块会从socket中获取数据做应用层的封装，解析出请求头、请求体并构造响应体），这样便从内核socket->libuv->js依次执行到开发者的业务逻辑中。

到此为止，相信读者已经明白node是如何处理客户端的请求了，那么下一步继续探究node是如何分发客户端的请求给子进程的。

### 请求分发策略

上节提到cluster模块默认采用RoundRobin调度策略，那么还有其他策略可以选择吗？答案是肯定的，在windows机器中，cluster模块采用的是共享服务端socket方式，通俗点说就是由操作系统进行调度客户端的请求，而不是由node程序调度。其实在node v0.8以前，默认的集群模式就是采用操作系统调度方式进行，直到cluster模块的加入才有了改变。

那么，RoundRobin调度策略到底是怎样的呢？

```
RoundRobinHandle.prototype.distribute = function(err, handle) {
  this.handles.push(handle);
  const worker = this.free.shift();
  if (worker)
    this.handoff(worker);
};

// 发送消息和handle给对应worker进程，处理业务逻辑
RoundRobinHandle.prototype.handoff = function(worker) {
  if (worker.id in this.all === false) {
    return;  // Worker is closing (or has closed) the server.
  }
  const handle = this.handles.shift();
  if (handle === undefined) {
    this.free.push(worker);  // Add to ready queue again.
    return;
  }
  const message = { act: 'newconn', key: this.key };
  sendHelper(worker.process, message, handle, (reply) => {
    if (reply.accepted)
      handle.close();
    else
      this.distribute(0, handle);  // Worker is shutting down. Send to another.
    this.handoff(worker);
  });
};
```

核心代码就是这两个函数，浓缩的是精华。`distribute函数负责筛选出处理请求的子进程，this.free数组存储空闲的子进程，this.handles数组存放待处理的用户请求。handoff函数获取排队中的客户端请求，并通过IPC发送句柄handle和newconn消息，等待子进程返回。当子进程返回正在处理请求消息时，在此执行handoff函数，继续分配请求给该子进程，不管该子进程上次请求是否处理完成（node的异步特性和事件循环可以让单进程处理多请求）。`按照这样的策略，主进程每fork一个子进程，都会调用handoff函数，进入该子进程的处理循环中。一旦主进程没有缓存的客户端请求时（this.handles为空），便会将当前子进程加入free空闲队列，等待主进程的下一步调度。这就是cluster模式的RoundRobin调度策略，每个子进程的处理逻辑都是一个闭环，直到主进程缓存的客户端请求处理完毕时，该子进程的处理闭环才被打开。

这么简单的实现带来的效果却是不小，经过全世界这么多使用者的尝试，主进程分发请求还是很平均的，如果RoundRobin的调度需求不满足你业务中的要求，你可以尝试仿照RoundRobin模块写一个另类的调度算法。

那么cluster模块在windows系统中采用的shared socket策略（后文简称SS策略）是什么呢？采用SS策略调度算法，子进程的服务器工作逻辑完全不同于上文中所讲的那样，子进程创建的TCP服务器会在底层侦听端口并处理响应，这是如何实现的呢？SS策略的核心在于IPC传输句柄的文件描述符，并且在C++层设置端口的**SO_REUSEADDR**选项，最后根据传输的文件描述符还原出handle(net.TCP)，处理请求。这正是shared socket名称由来，共享文件描述符。

**子进程继承父进程fd，处理请求**

```
import socket
import os
def main():
    serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serversocket.bind(("127.0.0.1", 8888))
    serversocket.listen(0)
    # Child Process
    if os.fork() == 0:
        accept_conn("child", serversocket)
    accept_conn("parent", serversocket)
def accept_conn(message, s):
    while True:
        c, addr = s.accept()
        print 'Got connection from in %s' % message
        c.send('Thank you for your connecting to %s\n' % message)
        c.close()
if __name__ == "__main__":
    main()
```

> 需要指出的是，在子进程中根据文件描述符还原出的handle，不能再进行bind(ip,port)和listen(backlog)操作，只有主进程创建的handle可以调用这些函数。子进程中只能选择accept、read和write操作。

既然SS策略传递的是master进程的服务端socket的文件描述符，子进程侦听该描述符，那么由谁来调度哪个子进程处理请求呢？这就是由操作系统内核来进行调度。可是内核调度往往出现[意想不到](https://www.baidu.com/s?wd=%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的效果，在linux下导致请求往往集中在某几个子进程中处理。这从内核的调度策略也可以推算一二，内核的进程调度离不开**上下文切换**，上下文切换的代价很高，不仅需要保存当前进程的**代码、数据和堆栈等用户空间数据，还需要保存各种寄存器，如PC，ESP**，最后还需要恢复被调度进程的上下文状态，仍然包括**代码、数据和各种寄存器**，因此代价非常大。而linux内核在调度这些子进程时往往倾向于唤醒最近被阻塞的子进程，上下文切换的代价相对较小。而且内核的调度策略往往受到当前系统的运行任务数量和资源使用情况，对专注于业务开发的http服务器影响较大，因此会造成某些子进程的负载严重不均衡的状况。那么为什么cluster模块默认会在windows机器中采用SS策略调度子进程呢？原因是node在windows平台采用的IOCP来最大化性能，它使得传递连接的句柄到其他进程的成本很高，因此采用默认的依靠操作系统调度的SS策略。

SS调度策略非常简单，主进程直接通过IPC通道发送handle给子进程即可，此处就不针对代码进行分析了。此处，笔者利用node的child_process模块实现了一个简易的SS调度策略的服务集群，读者可以更好的理解：

**master代码**

```
var net = require('net');
var cp = require('child_process');
var w1 = cp.fork('./singletest/worker.js');
var w2 = cp.fork('./singletest/worker.js');
var w3 = cp.fork('./singletest/worker.js');
var w4 = cp.fork('./singletest/worker.js');
var server = net.createServer();
server.listen(8000,function(){
  // 传递句柄
  w1.send({type: 'handle'},server);
  w2.send({type: 'handle'},server);
  w3.send({type: 'handle'},server);
  w4.send({type: 'handle'},server);
  server.close();
});
```

**child代码**

```
var server = require('http').createServer(function(req,res){
  res.write(cluster.isMaster + '');
  res.end(process.pid+'')
})
var cluster = require('cluster');
process.on('message',(data,handle)=>{
  if(data.type !== 'handle')
    return;
  handle.on('connection',function(socket){
    server.emit('connection',socket)
  });
});
```

这种方式便是SS策略的典型实现，不推荐使用者尝试。

#### 结尾

开篇提到的一些问题至此都已经解答完毕，关于cluster模块的一些具体实现本文不做详细描述，有兴趣感受node源码的同学可以在阅读本文的基础上再翻阅，这样[事半功倍](https://www.baidu.com/s?wd=%E4%BA%8B%E5%8D%8A%E5%8A%9F%E5%80%8D&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)。本文是在node源码和笔者的计算机网络基础之上混合后的产物，起因于笔者研究PM2的cluster模式下God进程的具体实现。在尝试几天仔细研读node cluster相关模块后有感于其良好的封装性，故产生将其内部实现原理和技巧向日常开发者所展示的想法，最后有了这篇文章。

那么，阅读了这篇文章，熟悉了cluster模式的具体实现原理，对于日常开发者有什么促进作用呢？首先，能不停留在**使用**层面，深入到具体实现原理中去，这便是比大多数人强了；在理解实现机制的阶段下，如果能反哺业务开发就更有意义了。比如，根据业务设计出更匹配的负载均衡逻辑；根据服务的日常QPS设置合理的backlog值等；最后，在探究实现的过程中，我们又回顾了许多离应用层开发人员难以接触到的底层网络编程和操作系统知识，这同时也是学习深入的过程。

接下来，笔者可能会抽时间针对node的其他常用模块做一次细致的解读。其实，node较为重要的**Stream**模块笔者已经分析过了，node中的Stream、深入node之Transform，经过深入探究之后在日常开发node应用中有着很大的提升作用，读者们可以尝试下。既然提到了Stream模块，那么结合本文的net模块解析，我们就非常容易理解node http模块的实现了，因为http模块正是基于**net和Stream**模块实现的。那么下一篇文章就针对http模块做深入解析吧！

### 介绍pm2

node.js部署PM2

如果直接通过node app来启动，如果报错了可能直接停在整个运行，supervisor感觉只是拿来用作开发环境的。再网上找到pm2.目前似乎最常见的线上部署nodejs项目的有forever,pm2这两种。
使用场合:
- supervisor是开发环境用。
- forever管理多个站点，每个站点访问量不大，不需要监控。
- nodemon 是开发环境使用，修改自动重启。
- pm2 网站访问量比较大,需要完整的监控界面。

#### PM2的主要特性:

1. 内建负载均衡（使用Node cluster 集群模块）
2. 后台运行
3. 0秒停机重载，我理解大概意思是维护升级的时候不需要停机.
4. 具有Ubuntu和CentOS 的启动脚本
5. 停止不稳定的进程（避免无限循环）
6. 控制台检测
7. 提供 HTTP API
8. 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )

**1、最常用的属nohup了，其实就是在后台执行进程，末尾加个&**

```
[zhoujie@ops-dev ~]$ nohup node /home/zhoujie/ops/app.js &
[1] 31490nohup: ignoring input and appending output to `nohup.out'
```
即此时程序已启动，直接访问即可，原程序的的标准输出被自动改向到当前目录下的nohup.out文件，起到了log的作用。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。

该命令的一般形式为：**nohup command &**这个不太靠谱的样子，经常默默的进程在后台就挂了

 **2、用screen另开一个屏幕，这种方式可以直接在屏幕上看到程序运行情况**

给该应用程序开个screen，如：screen -r ops ，用npm start启动，
退出该后台：ctrl + a，再按d，可不能直接ctrl +c，否则就退出了
这种方式很不专业，呵呵，不过方便看在生产环境的操作。
这个本质上用的forever，package.json里配置的：

```
  "scripts": {
    "start": "forever app.js",
    "test": "supervisor app.js"
  },
```
　　**3、PM2**
使用它要先安装它，用root账号和全局模式安装一下：

```
npm install -g pm2
```
用它来启动程序（在当前目录下可以直接启动，**pm2 start app.js** --name uops）
[![复制代码](F:\Code\github\前端面试\assets\copycode.gif)](javascript:void(0);)

```
[zhoujie@ops-dev uops]$ pm2 start app.js 
[PM2] Spawning PM2 daemon
[PM2] Success
[PM2] Process app.js launched
┌──────────┬────┬──────┬─────┬────────┬───────────┬────────┬─────────────┬──────────┐
│ App name │ id │ mode │ PID │ status │ restarted │ uptime │      memory │ watching │
├──────────┼────┼──────┼─────┼────────┼───────────┼────────┼─────────────┼──────────┤
│ app      │ 0  │ fork │ 308 │ online │         0 │ 0s     │ 21.879 MB   │ disabled │
└──────────┴────┴──────┴─────┴────────┴───────────┴────────┴─────────────┴──────────┘
 Use `pm2 info <id|name>` to get more details about an app
[zhoujie@ops-dev uops]$
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

看，它显示了Success，程序已经默默的成功的启动了，可以实时监控程序的运行，比如执行个**pm2 restart**，则上述restarted那栏变成1，可以显示程序运行了多长时间、占用内存大小，实在是太赞啦！

![img](F:\Code\github\前端面试\assets\071738232036886.jpg)

终止程序也很简单：**pm2 stop** 

![img](F:\Code\github\前端面试\assets\071742299685132.jpg)

列举出所有用pm2启动的程序：**pm2 list**

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[zhoujie@ops-dev uops]$ pm2 list
┌──────────┬────┬──────┬─────┬────────┬───────────┬────────┬─────────────┬──────────┐
│ App name │ id │ mode │ PID │ status │ restarted │ uptime │      memory │ watching │
├──────────┼────┼──────┼─────┼────────┼───────────┼────────┼─────────────┼──────────┤
│ app      │ 0  │ fork │ 984 │ online │         1 │ 3s     │ 64.141 MB   │ disabled │
└──────────┴────┴──────┴─────┴────────┴───────────┴────────┴─────────────┴──────────┘
 Use `pm2 info <id|name>` to get more details about an app
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

查看启动程序的详细信息：**pm2 describe** id

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[zhoujie@ops-dev uops]$ pm2 desc 0
Describing process with pid 0 - name app
┌───────────────────┬─────────────────────────────────────────┐
│ status            │ online                                  │
│ name              │ app                                     │
│ id                │ 0                                       │
│ path              │ /home/zhoujie/uops/app.js               │
│ args              │                                         │
│ exec cwd          │ /home/zhoujie/uops                      │
│ error log path    │ /home/zhoujie/.pm2/logs/app-error-0.log │
│ out log path      │ /home/zhoujie/.pm2/logs/app-out-0.log   │
│ pid path          │ /home/zhoujie/.pm2/pids/app-0.pid       │
│ mode              │ fork_mode                               │
│ node v8 arguments │                                         │
│ watch & reload    │ ✘                                       │
│ interpreter       │ node                                    │
│ restarts          │ 1                                       │
│ unstable restarts │ 0                                       │
│ uptime            │ 93s                                     │
│ created at        │ 2015-01-07T09:41:25.672Z                │
└───────────────────┴─────────────────────────────────────────┘
[zhoujie@ops-dev uops]$ 
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

通过pm2 list命令来观察所有运行的进程以及它们的状态已经足够好了.但是怎么来追踪它们的资源消耗呢?别担心,用这个命令:**pm2 monit**

**可以得到进程(以及集群)的CPU的使用率和内存占用**(ctrl +c 退出)

![img](F:\Code\github\前端面试\assets\071748590155142.jpg)

**实时集中log处理：pm2 logs**

![img](F:\Code\github\前端面试\assets\071752377962737.jpg)

**强大API： pm2 web**

你想要监控所有被PM2管理的进程,而且同时还想监控运行这些进程的机器的状态，

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[zhoujie@ops-dev uops]$ pm2 web
Launching web interface on port 9615
[PM2] Process /usr/local/node/lib/node_modules/pm2/lib/HttpInterface.js launched
[PM2] Process launched
┌────────────────────┬────┬──────┬──────┬────────┬───────────┬────────┬─────────────┬──────────┐
│ App name           │ id │ mode │ PID  │ status │ restarted │ uptime │      memory │ watching │
├────────────────────┼────┼──────┼──────┼────────┼───────────┼────────┼─────────────┼──────────┤
│ app                │ 0  │ fork │ 984  │ online │         1 │ 9m     │ 74.762 MB   │ disabled │
│ pm2-http-interface │ 1  │ fork │ 1878 │ online │         0 │ 0s     │ 15.070 MB   │ disabled │
└────────────────────┴────┴──────┴──────┴────────┴───────────┴────────┴─────────────┴──────────┘
 Use `pm2 info <id|name>` to get more details about an app
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

启动程序的时候顺便在浏览器访问：http://localhost:**9615**

擦，我眼睛被亮瞎了，这么炫酷，竟然把部署的服务器的信息和程序的信息都显示出来了：

![img](F:\Code\github\前端面试\assets\071807101408031.png)

这东西对程序运行的监控页面的开发实在是太有帮助了，呵呵~~

监控：pm2 monit
实时集中log处理: pm2 logs
API:pm2 web (端口：9615 ) 

#### 常用命令总结：
```
$ pm2 logs	显示所有进程日志
```

```
$ pm2 stop all	停止所有进程
```

```
$ pm2 restart all	重启所有进程
```

```
$ pm2 reload all	0秒停机重载进程 (用于 NETWORKED 进程)
```

```
$ pm2 stop 0	停止指定的进程
```

```
$ pm2 restart 0	重启指定的进程
```

```
$ pm2 startup	产生 init 脚本 保持进程活着
```

```
$ pm2 web	运行健壮的 computer API endpoint (http://localhost:9615)
```

```
$ pm2 delete 0	杀死指定的进程
```

```
$ pm2 delete all	杀死全部进程
```

运行进程的不同方式：
`$ pm2 start app.js -i max` 根据有效CPU数目启动最大进程数目
`$ pm2 start app.js -i 3` 启动3个进程
`$ pm2 start app.js -x` 用fork模式启动 app.js 而不是使用 cluster
`$ pm2 start app.js -x -- -a 23` 用fork模式启动 app.js 并且传递参数 (-a 23)
`$ pm2 start app.js --name serverone` 启动一个进程并把它命名为 serverone
`$ pm2 stop serverone` 停止 serverone 进程
`$ pm2 start app.json` 启动进程, 在 app.json里设置选项
`$ pm2 start app.js -i max -- -a 23` 在--之后给 app.js 传递参数
`$ pm2 start app.js -i max -e err.log -o out.log` 启动 并 生成一个配置文件

#### 配置pm2启动文件

在项目根目录添加一个processes.json：
内容如下:

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
{
  "apps": [
    {
      "name": "mywork",
      "cwd": "/srv/node-app/current",
      "script": "bin/www",
      "log_date_format": "YYYY-MM-DD HH:mm Z",
      "error_file": "/var/log/node-app/node-app.stderr.log",
      "out_file": "log/node-app.stdout.log",
      "pid_file": "pids/node-geo-api.pid",
      "instances": 6,
      "min_uptime": "200s",
      "max_restarts": 10,
      "max_memory_restart": "1M",
      "cron_restart": "1 0 * * *",
      "watch": false,
      "merge_logs": true,
      "exec_interpreter": "node",
      "exec_mode": "fork",
      "autorestart": false,
      "vizion": false
    }
  ]
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

说明:

- apps:json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用
- name:应用程序名称
- cwd:应用程序所在的目录
- script:应用程序的脚本路径
- log_date_format:
- error_file:自定义应用程序的错误日志文件
- out_file:自定义应用程序日志文件
- pid_file:自定义应用程序的pid文件
- instances:
- min_uptime:最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量
- max_restarts:设置应用程序异常退出重启的次数，默认15次（从0开始计数）
- cron_restart:定时启动，解决重启能解决的问题
- watch:是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。
- merge_logs:
- exec_interpreter:应用程序的脚本类型，这里使用的shell，默认是nodejs
- exec_mode:应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork
- autorestart:启用/禁用应用程序崩溃或退出时自动重启
- vizion:启用/禁用vizion特性(版本控制)

可以通过`pm2 start processes.json`来启动。
也可以把命令写在package.json里。如下:

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 "scripts": {
    "dev": "NODE_ENV=development nodemon src/server.js & NODE_ENV=development nodemon src/server/action-server.js & tools/redis/socket.js",
    "dev_read_redis": "NODE_ENV=development nodemon src/app.js",
    "start": "NODE_ENV=production nodemon src/app.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

通过`npm run start`来启动。

> 关于pm2远程部署到多台机器，参考：http://pm2.keymetrics.io/docs/usage/deployment

> 官网：http://pm2.keymetrics.io/docs/usage/quick-start/#42-starts

### master挂了的话pm2怎么处理



### 如何和MySQL进行通信

node安装mysql，使用命令即可`npm install mysql`

> 链接 
>
> [node如何和MySQL进行通信]:http://www.fly63.com/article/detial/1343

**链接mysql的流程**

```
var mysql  = require('mysql');  //调用MySQL模块

//创建一个connection
var connection = mysql.createConnection({     
  host     : '192.168.0.200',       //主机
  user     : 'root',               //MySQL认证用户名
  password : 'abcd',        //MySQL认证用户密码
  port: '3306',                   //端口号
}); 
//创建一个connection
connection.connect(function(err){
    if(err){        
          console.log('[query] - :'+err);
        return;
    }
      console.log('[connection connect]  succeed!');
});  
//执行SQL语句
connection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) { 
     if (err) {
             console.log('[query] - :'+err);
        return;
     }
     console.log('The solution is: ', rows[0].solution);  
});  
//关闭connection
connection.end(function(err){
    if(err){        
        return;
    }
      console.log('[connection end] succeed!');
});
```

**防止SQL注入**

防止SQL注入，可以使用pool.escape()和connect.escape() 

### React声明周期及自己的理解

[react生命周期的基本用法]:https://www.jianshu.com/p/c9bc994933d5

props,state,render()函数：

1. render()函数会在props,state改变时触发。
2. 子组件的render()函数会在父组件render()执行的时候被执行（这会导致一些性能问题，我们可以在子组件的componentshouldupdate函数中进行判断，优化性能）


   在render()，创建虚拟dom，进行diff算法，更新dom树。

> 初始化-> 挂载 -> 更新 ->卸载

注意：不要在render中修改state,会导致死循环。

**V16 生命周期函数用法建议**

```
class ExampleComponent extends React.Component {
  // 用于初始化 state
  constructor() {}
  
  // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用
  // 因为该函数是静态函数，所以取不到 `this`
  // 如果需要对比 `prevProps` 需要单独在 `state` 中维护
  static getDerivedStateFromProps(nextProps, prevState) {}
  
  // 判断是否需要更新组件，多用于组件性能优化
  shouldComponentUpdate(nextProps, nextState) {}
  
  // 组件挂载后调用
  // 可以在该函数中进行请求或者订阅
  componentDidMount() {}
  
  // 用于获得最新的 DOM 数据
  getSnapshotBeforeUpdate() {}
  
  // 组件即将销毁
  // 可以在此处移除订阅，定时器等等
  componentWillUnmount() {}
  
  // 组件销毁后调用
  componentDidUnMount() {}
  
  // 组件更新后调用
  componentDidUpdate() {}
  
  // 渲染组件函数
  render() {}
  
  // 以下函数不建议使用
  UNSAFE_componentWillMount() {}
  UNSAFE_componentWillUpdate(nextProps, nextState) {}
  UNSAFE_componentWillReceiveProps(nextProps) {}
}
```

 **2.componentWillMount 组件将要挂载**

> 1、组件刚经历constructor,初始完数据
> 2、组件还未进入render，组件还未渲染完成，dom还未渲染

**3.componentDidMount 组件渲染完成**

组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染

**4.componentWillReceiveProps (nextProps)**

componentWillReceiveProps在接受父组件改变后的props需要重新渲染组件时用到的比较多
 它接受一个参数

> 1.nextProps
>  通过对比nextProps和this.props，将nextProps setState为当前组件的state，从而重新渲染组件

**5.shouldComponentUpdate(nextProps,nextState)**

唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，（暂时这么理解，其实setState以后有些情况并不会重新渲染，比如**数组引用不变**）在这里return false可以阻止组件的更新

 **因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断**

**6.componentWillUpdate (nextProps,nextState)**

shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState

**7.render函数**

render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到**最小的有差异的DOM节点**，并重新渲染

**8、componentDidUpdate(prevProps,prevState)**

组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。

**9、componentWillUnmount ()**

> 1.clear你在组建中所有的setTimeout,setInterval
>  2.移除所有组建中的监听 removeEventListener
>  3.也许你会经常遇到这个warning:

### 如何配置React-Router

[React Router 使用教程阮一峰]:http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu

### 路由的动态加载模块



### 服务端渲染SSR

什么是服务器端渲染

渲染：就是将数据和模版组装成html

**后端渲染（服务器端渲染）**

多年前，Web是一群由HTML和CSS构建的静态页面，没有太多的交互性。每个用户行为要求服务器来创建和提供一个完整的页面。后端渲染HTML的情况下，浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的**HTML字符串**，这里的计算就是服务器经过解析存放在服务器端的模板文件来完成的，在这种情况下，浏览器只进行了HTML的解析，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户。

​        国企的网站全部是使用的后端渲染，也就是说，你点击一下，他就会刷新一个，然后从后台请求新的页面数据。

**好处：前端耗时少（前端只负责将html进行展示），利于SEO**

**坏处：网络传输数据量大，占用（部分、少部分）服务器运算资源，response 出的数据量会（稍）大点，模板改了前端的交互和样式什么的一样得跟着联动修改**

 

**前端渲染（客户端渲染）**

前端渲染的方式起源于JavaScript的兴起，ajax的大热更是让前端渲染更加成熟，前端渲染真正意义上的实现了前后端分离，前端只专注于UI的开发，后端只专注于逻辑的开发，前后端交互只通过约定好的API来交互，后端提供json数据，前端循环json生成DOM插入到页面中去。

**好处：网络传输数据量小（减少了服务器压力）**

**坏处：前端耗时较多，不利于SEO**

 

​        其实前后端的渲染本质是一样的，都是字符串的拼接，将数据渲染进一些固定格式的html代码中形成最终的html展示在用户页面上。  因为字符串的拼接必然会损耗一些性能资源。 所以……

​        如果在**服务器端渲染**，那么消耗的就是server端的性能。所以用户量达到一定程度后，后端会考虑缓存部分数据，避免消耗过多资源重复渲染一些对及时性要求并不高的地方以节约资源。例如常见的排行榜，可以将渲染后的模块缓存起来，十分钟更新一次。

​        如果是在客户端渲染，常见的手段，比如是直接生成DOM插入到html 中，或者是使用一些前端的模板引擎等。他们初次渲染的原理大多是将原html中的数据标记（例如{{text}}）替换。一般来说只要不作死无脑用了document.write，浏览器端初次渲染的性能消耗都是可以接受的。

浏览器端渲染的难点在于数据变更后，页面响应式变更时如何节省资源？要知道DOM直接读写的速度是很慢的，而且不小心还会触发重绘，在复杂的SPA下直接读写DOM带来的影响会很明显。拿React、Vue来举例子，在数据变更后，他会帮你diff，没有改变可以复用的部分是不会重新渲染一遍的。

 

**SEO**
browser端渲染是对搜索引擎不太友好的，虽然SPA怎么做SEO已经有过无数讨论和实践，但是browser端很大程度是不如server端渲染容易做SEO。

> 后端渲染html 叫**吐**或者**喷，爬虫**可以看到完整的呈现源码
> 前端模板渲染html叫**填，爬虫**看不到完整的呈现源码

**维护**

server端渲染很多时候前后端是一起完成的。有的团队是前端开发人员直接写模板文件，但是也有的团队是前端写了静态html文件，后端改为模板。后一种团队在维护时是比较蛋疼的，改个css都要前后端在一起搞定（我的上一家公司就是这么做的）

 

**如何选择**

关于在server端还是在browser端渲染的选择，更多的是要看业务场景。

 

例如一个注重SEO的新闻站点，非强交互的页面，做成SPA意义并不大，还是建议server端渲染。
像后台管理页面，或者是QQ空间这类强交互的网页应用，可以尝试浏览器端渲染。后端开发人员也能更加专注于接口服务的提供，不用去考虑页面的渲染问题，分工合作更加愉快。

在浏览器端渲染时，如果数据量并不大，也没有什么大的改变，那么自己用原生的DOM API去操作绰绰有余了，即使有时候有些操作会浪费一些性能资源，影响也不会太大，反而引入了框架和库却只用了一部分功能是一种浪费。但是如果做一个复杂的页面应用，我还是建议使用Vue这类库/框架来帮你完成。一方面来说，他们会帮你把业务逻辑抽象，不让你去关注渲染这些操作，可以提升开发效率；另一方面，恐怕大多数人自己实现渲染以及数据变更后的DOM变更未必会比库/框架做得好。如果他能做的更好，一定要请他为主流框架/库去提PR或者issues来帮助库/框架做的更好；

### 介绍路由的history



### 介绍Redux数据流的流程
### Redux如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理

### 多个组件之间如何拆分各自的state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块

### 使用过的Redux中间件

### 如何解决跨域的问题



### 常见Http请求头

### 移动端适配1px的问题

**CSS像素为1px宽的直线，对应的物理像素是不同的，可能是2px或者3px,而设计师想要的1px宽的直线,其实就是1物理像素宽**

1.首先你要知道什么是绝对长度单位，什么是相对长度单位？绝对长度单位：pt;pt point点，印刷行业常用单位，等于1/72英寸。相对长度单位：px、em、rem、vw、vh;

px pixel指一张图片中最小的点。如果点很小，那画面就清晰，我们称它为“分辨率高”，反之，就是“分辨率低”。所以，像素的大小是会“变”的。

em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。

rem是CSS3新增的一个相对单位。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。兼容性IE9+。

1vw等于视口宽度（viewport width）的百分之一，也就是说100vw就是视口的宽度。同理，1vh等于视口高度（viewport height）的百分之一。vw,vh是css3中新增的单位。通过测试发现“视区/视口”指浏览器内部的可视区域大小，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。**这两个单位和%百分比有点类似，只是%一般相对于父元素**，另外：**vh、vw永远都是相对于视窗大小的**。最主要能解决的一个问题就是原来想要做高度自适应很困难，现在很容易了。一个body{height: 100vh}就搞定了。兼容性IE9+。最后，为什么要提起vw，vh？小程序最近很火，它在它的开发文档里也提到这个单位，用来做适配。也就是说小程序是支持这两个单位的。验证了那句话，事出必有因。

2.然后你需要知道什么是屏幕尺寸、屏幕分辨率、屏幕像素密度？屏幕尺寸：指屏幕的对角线的长度，单位是英寸。常见屏幕尺寸：

iphone43.5英寸

iphone54英寸

iphone64.7英寸

iphone6 plus5.5英寸

iphoneX5.8英寸

屏幕分辨率：指在横纵上的像素点数。常见屏幕分辨率：

iphone4640*960

iphone5640*1136

iphone6750*1334

iphone6 plus1080*1920

iphoneX1125*2436

屏幕像素密度（dpi或ppi）: 屏幕上每英寸可以显示的像素点的数量。dpi=ppi。像素密度dpi或ppi=对角线分辨率/屏幕尺寸=屏幕对角线上的像素点数/对角线长度 = √ （屏幕横向像素点^2 + 屏幕纵向像素点^2）/对角线长度。注：对角线长度即屏幕尺寸。手机按屏幕划分，屏幕像素密度(dpi/ppi)越大越清晰。谷歌区分手机屏幕按照：mdpi、hdpi、xhdpi、xxhdpi；苹果区分手机屏幕是按照：非高清屏，高清屏（视网膜屏即retina屏）、超高清屏;常见屏幕ppi:

Iphone4326ppi

Iphone5326ppi

Iphone6326ppi

Iphone6 plus401ppi

Iphone X:424ppi

小知识点：HD高清即指分辨率达到720p以上的格式。视网膜（retina）设备：分辨率达到300ppi(每英寸300个像素点)，所以苹果从iphone4开始就已经是retina屏了。在retina屏上用1倍图会模糊。普通屏幕下即dpr=1，用两倍图片，肉眼看上去虽然图片不会模糊，但是会觉得图片缺少一些锐利度，或者是有点色差，但可以接受。同样用在超retina屏,dpr=3比如iphone6 plus、iphonex上，就是有点失色，但也可以接受，所以我们只要一个@2x的图即可。3.dpr是什么?英文全称devicePixelRatio，设备像素比。设备像素比dpr=物理像素的个数/设备独立像素（通常指1个）;另外dpr可以直接由js的内置属性获得：dpr=window.devicePixelRatio;设备独立像素（又称设备无关像素 Device Independent Pixels 、密度独立性 Density Independent或设备独立像素，简称DIP或DP）是一种物理测量单位。设备独立像素dip到底有什么用呢？dip用来辅助区分视网膜设备还是非视网膜设备。1dp表示在屏幕像素点密度为160ppi时1px长度。1px问题由于有retina屏的存在，移动端设计稿多是以手机尺寸的2倍尺寸出，这时设计稿上的1px像素，如果前端也写成1px的话，在devicePixelRatio=2的retina屏下会显示成2px，所以在高清屏下看着1px总是感觉变胖了。也就是说按正常前端的开发，我们应该写成0.5px,但是一些老系统，比如ios7以下，android等会把0.5px, 解读成0px,就没有边框了，所以只能写成1px。好在，现在css3的普及，这个问题可以这样解决：利用transform:scale(x,y)，设置线条为1px，然后通过transform:scale(x,y)来缩放线条为原来的一半，可显示0.5px的线条。

### 介绍flex布局

> 下面两个链接 有实际样例

> [flex布局简介](https://www.cnblogs.com/starof/p/4894140.html)

> [弹性布局Flex介绍](https://www.cnblogs.com/sharpall/p/6703868.html)

 **用于父元素的样式**

flex模型 【新】

- **display:flex; flexbox模型只适用于直系子代**
- flex-direction: row | row-reverse | column | column-reverse;子元素是如何**排列**
- **justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;**子元素**水平**排列方式
- align-items: flex-start | flex-end | center | baseline | stretch;子元素**垂直**排列方式
- flex-wrap: nowrap | wrap | wrap-reverse; 
- align-content: flex-start | flex-end | center | space-between | space-around | stretch;

**用于子元素的样式**

flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ],默认值 0 1 auto。

### 其他css方式设置垂直居中

**方法1：table-cell**

html结构：

```
`<div ``class``=``"box box1"``>``        ``<span>垂直居中</span>``</div>`
```

css：

```
`.box1{``    ``display: table-cell;``    ``vertical-align: middle;``    ``text-align: center;        ``}`
```

**方法2：display:flex**

```
`.box2{``    ``display: flex;``    ``justify-content:center;``    ``align-items:Center;``}`
```

**方法3：绝对定位和负边距**

```
.box3{position:relative;}
.box3 span{
            position: absolute;
            width:100px;
            height: 50px;
            top:50%;
            left:50%;
            margin-left:-50px;
            margin-top:-25px;
            text-align: center;
        }
```

**方法4：绝对定位和0**

```
.box4 span{
  width: 50%; 
  height: 50%; 
  background:` `#000;
  overflow: auto; 
  margin: auto; 
  position: absolute; 
  top: 0; left: 0; bottom: 0; right: 0; 
}
```

**方法5：translate**

```
.box6 span{
    position: absolute;
    top:50%;
    left:50%;
    width:100%;
    transform:translate(-50%,-50%);
    text-align: center;
        }
```

**方法6：display:inline-block**

```
.box7{
  text-align:center;
  font-size:0;
}
.box7 span{
  vertical-align:middle;
  display:inline-block;
  font-size:16px;
}
.box7:after{
  content:'';
  width:0;
  height:100%;
  display:inline-block;
  vertical-align:middle;
}
```

**方法7：display:flex和margin:auto**

```
.box8{
    display: flex;
    text-align: center;
}
.box8 span{margin: auto;}
```

**方法8：display:-webkit-box**

```
.box9{
    display: -webkit-box;
    -webkit-box-pack:center;
    -webkit-box-align:center;
    -webkit-box-orient: vertical;
    text-align: center
}
```

**方法9：display:-webkit-box**

```
<div class="floater"></div>  
<div class="content"> Content here </div>  
```

```
.floater {
    float:left; 
    height:50%; 
    margin-bottom:-120px;
}
.content {
    clear:both; 
    height:240px; 
    position:relative;
}
```

### 居中为什么要使用transform（为什么不使用marginLeft/Top）

首先。我们了解下transform是干嘛的。

在MDN中的官方解释：CSS**transform**属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。简言之，transform可以操作一些动画、位移效果。

margin top/left，我们应该很熟悉，用得比较多。

那为什么说，居中显示，CSS3标准的transform更胜一筹呢？我们主要还是从浏览器渲染的性能方面考虑。

\1. 浏览器渲染过程

我们知道，浏览器中有JS引擎和渲染引擎，对于HTML页面的渲染就靠渲染引擎来完成。下面是chrome浏览器页面渲染的整体过程图：

![Chromeæ¸²æè¿ç¨](F:\Code\github\前端面试\assets\16826e0f708fe502)

([www.w3cplus.com/animation/a…](https://link.juejin.im?target=https%3A%2F%2Fwww.w3cplus.com%2Fanimation%2Fanimation-performance.html) © [w3cplus.com](https://link.juejin.im?target=https%3A%2F%2Fwww.w3cplus.com%2F))

从上面的流程图中不难看出，Chrome渲染主要包括Parse Html、Recalculate Style、Layout、Paint、Image Decode、Image Resize和Composite Layers等。相对应的中文表述就是：html解析、查找并计算样式、排布、绘制、图片解码、图片大小设置、合并图层并输出页面到屏幕。浏览器最终渲染出来的页面，跟Photoshop有点类似，是由多个图层合并而来。

\2. transform的原理：

transform是通过创建一个RenderLayers合成层，拥有独立的GraphicsLayers。每一个GraphicsLayers都有一个Graphics Context，其对应的RenderLayers会paint进Graphics Context中。合成器（Compositor）最终会负责将由Graphics Context输出的位图合并成最终屏幕展示的图案。

满足如下条件的RenderLayers，会被认为是一个独立的合成层：

- 有3D或者perspective transform的CSS属性的层
- video元素的层
- canvas元素的层
- flash
- 对opacity和transform应用了CSS动画的层
- 使用了CSS滤镜（filters）的层
- 有合成层后代的层
- 同合成层重叠，且在该合成层上面（z-index）渲染的层

如果RenderLayer是一个合成层，那么它有属于它自己的单独的GraphicsLayer，否则它和它的最近的拥有GraphicsLayer的父layer共用一个GraphicsLayer。

由此可见，transform发生在Composite Layer这一步，它所引起的paint也只是发生在单独的GraphicsLayer中，并不会引起整个页面的回流重绘。

\3. GPU

我们经常会听到GPU会加速渲染，那GPU在这里又扮演什么角色呢？

前面说到，合成器会负责将层合成绘制为最终的屏幕画面。在硬件加速体系结构，合成由GPU负责。在chrome浏览器多进程模型中，有一个专门的进程来负责传递Render进程的命令，即GPU进程。Render进程和GPU进程是通过共享内存传递的。

Render进程可以快速 的将命令发给命令缓冲区，并且返回到CPU密集的render活动中，留给GPU进程去处理这些命令。我们可以充分利用多内核机器上的GPU进程和CPU进程。这也是为什么GPU会加速渲染，使transform渲染速度更快的又一原因。

\4. margin top/left

marign：外边距，定义元素周围的空间；简言之，可以改变元素的位移。在浏览器页面渲染的时候，margin可以控制元素的位置，也就是说，改变margin，就会改变render tree的结构，必定会引起页面layout回流和repaint重绘。

因此，从浏览器性能考虑，transform会比margin更省时间。

**但是，transform真的处处适用吗？**

\5. transform的局限性

上面提到，transform实际上也是用到了GPU加速，也就是说占用了内存。由此可见创建GraphicsLayer，虽然洁身了layout，paint阶段，但Layer创建的越多，占用内存就会越大，而过多的渲染开销会超过性能的改善。

因此，当且仅当需要的时候，才会为元素创建渲染层。

### 使用过webpack里面哪些plugin和loader

**常用Loaders**

```
less-loader, sass-loader
    处理样式
    
url-loader, file-loader
    两个都必须用上。否则超过大小限制的图片无法生成到目标文件夹中

babel-loader，babel-preset-es2015，babel-preset-react
    js处理，转码

expose?*
    eg:
    {
        test: require.resolve('react'),
        loader: 'expose?React'
    }

expose-loader
    将js模块暴露到全局，如果
```

**常用插件Plugin**

**config类**

```
    NormalModuleReplacementPlugin
        匹配resourceRegExp，替换为newResource

        
    ContextReplacementPlugin
        替换上下文的插件
        
    IgnorePlugin
        不打包匹配文件
    
    PrefetchPlugin
        预加载的插件，提高性能
    
    ResolverPlugin
        替换上下文的插件
    
    ContextReplacementPlugin
        替换上下文的插件
    
    
```

 **optimize**

```
    DedupePlugin
        打包的时候删除重复或者相似的文件
        
    MinChunkSizePlugin
        把多个小模块进行合并，以减少文件的大小
        
    LimitChunkCountPlugin
        限制打包文件的个数
        
    MinChunkSizePlugin
        根据chars大小，如果小于设定的最小值，就合并这些小模块，以减少文件的大小
    
    OccurrenceOrderPlugin
        根据模块调用次数，给模块分配ids，常被调用的ids分配更短的id，使得ids可预测，降低文件大小，该模块推荐使用
        
    UglifyJsPlugin
        压缩js
        
    ngAnnotatePlugin
        使用ng-annotate来管理AngularJS的一些依赖
     
    CommonsChunkPlugin
        多个 html共用一个js文件(chunk)
    
    
```

**dependency injection**

```
    DefinePlugin
        定义变量，一般用于开发环境log或者全局变量
    
    ProvidePlugin
        自动加载模块，当配置（$:'jquery'）例如当使用$时，自动加载jquery
        
```

**other**

```
    HotModuleReplacementPlugin
        模块热替换,如果不在dev-server模式下，需要记录数据，recordPath，生成每个模块的热更新模块
    
    ProgressPlugin
        编译进度
        
    NoErrorsPlugin
        报错但不退出webpack进程
    
    HtmlWebpackPlugin 
        生成html
        
```

**常用alias**

```
alias的配置项目，能够让开发者指定一些模块的引用路径。对一些经常要被import或者require的库，如react,我们最好可以直接指定它们的位置，这样webpack可以省下不少搜索硬盘的时间。
```

![clipboard.png](https://segmentfault.com/img/bVvAy7?w=575&h=126)

### webpack里面的插件是怎么实现的



### dev-server是怎么跑起来

**初试——监听入口的JS文件**

我们可以监听入口文件和其它被它引用（导入）的文件，并在文件更新的时候，通知浏览器刷新网页。

**基本原理**

其实就是借助Express开启一个服务器，然后设置两个路由出口：

1. 静态资源出口：可以通过devServer的字段 `contentBase` 设置静态资源目录
2. webpack output的出口：默认是 `/` ，可以通过devServer的字段 `publicPath` 设置

所以，我可以看出，webpack output其实就是Express的一个router对象，webpack根据入口文件观察相关的文件，并在它们发生变化的时候，重新编译打包，并输出到router对象上，这样我们就可以访问该router拿到最新的资源，不过这个资源是放在内存上的，并不是文件系统上。

网页和webpack-dev-server是通过websocket协议互联的。当监听到文件变化的时候，会通过websocket通知网页调用reload接口刷新页面。



### 项目优化

1、规范代码，去除没有被用到的变量声明以及引用。

2、规范代码，替换过时的和不推荐使用的方法。

3、注释优化。我个人认为，注释优化可以分成三种，一种是加和改，一种是减。 
加，就是对于那些负责具体功能和业务逻辑的类以及实体类的属性，如果没有注释我们应该加上注释，这样方便后续的维护，起码让人一眼就知道这个类、这个方法、这个属性是什么作用是什么意思。 

4、代码逻辑上的优化。

5、据库优化。 可以分为两步，一个是sql语句的优化，一个就是表结构、索引相关的优化。 

7.代码包优化

- 屏蔽sourceMap
- 对项目代码中的JS/CSS/SVG(*.ico)文件进行gzip压缩
- 对路由组件进行懒加载

8.VUE源码优化

v-if 和 v-show选择调用 

- v-show和v-if的区别是：v-if是懒加载，当状态为true时才会加载，并且为false时不会占用布局空间；v-show是无论状态是true或者是false，都会进行渲染，并对布局占据空间对于在项目中，需要频繁调用，不需要权限的显示隐藏，可以选择使用v-show，可以减少系统的切换开销。

为item设置唯一key值， 

- 在列表数据进行遍历渲染时，需要为每一项item设置唯一key值，方便vuejs内部机制精准找到该条列表数据。当state更新时，新的状态值和旧的状态值对比，较快地定位到diff。

细分vuejs组件 

- 在项目开发过程之中，第一版本把所有的组件的布局写在一个组件中，当数据变更时，由于组件代码比较庞大，vuejs的数据驱动视图更新比较慢，造成渲染比较慢。造成比较差的体验效果。所以把组件细分，比如一个组件，可以把整个组件细分成轮播组件、列表组件、分页组件等。

减少watch的数据 

- 当组件某个数据变更后需要对应的state进行变更，就需要对另外的组件进行state进行变更。可以使用watch监听相应的数据变更并绑定事件。当watch的数据比较小，性能消耗不明显。当数据变大，系统会出现卡顿，所以减少watch的数据。其它不同的组件的state双向绑定，可以采用事件中央总线或者vuex进行数据的变更操作。

内容类系统的图片资源按需加载 

- 对于内容类系统的图片按需加载，如果出现图片加载比较多，可以先使用v-lazy之类的懒加载库或者绑定鼠标的scroll事件，滚动到可视区域先再对数据进行加载显示，减少系统加载的数据。

SSR(服务端渲染) 

- 如果项目比较大，首屏无论怎么做优化，都出现闪屏或者一阵黑屏的情况。可以考虑使用SSR(服务端渲染)，vuejs官方文档提供next.js很好的服务端解决方案，但是局限性就是目前仅支持Koa、express等Nodejs的后台框架，需要webpack支持。目前自己了解的就是后端支持方面，vuejs的后端渲染支持php，其它的不太清楚。

9.用户体验优化

- better-click防止iphone点击延迟 
  - 在开发移动端vuejs项目时，手指触摸时会出现300ms的延迟效果，可以采用better-click对ipone系列的兼容体验优化。
- 菊花loading 
  - 菊花loading，在加载资源过程之中，可以提供loading。此菊花loading不是那菊花。所以可以自由选择自己喜欢的菊花。
- 骨架屏加载
  - 在首屏加载资源较多，可能会出现白屏和闪屏的情况。体验不好。盗图一波，小米商城使用骨架屏进行首屏在资源数据还没有加载完成时显示，给很好的体验效果。
  - 

### 抽取公共文件是怎么配置的

**为什么需要提取公共代码**

大型网站通常会由多个页面组成，每个页面都是一个独立的单页应用。 但由于所有页面都采用同样的技术栈，以及使用同一套样式代码，这导致这些页面之间有很多相同的代码。

如果每个页面的代码都把这些公共的部分包含进去，会造成以下问题：

- 相同的资源被重复的加载，浪费用户的流量和服务器的成本；
- 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。

如果把多个页面公共的代码抽离成单独的文件，就能优化以上问题。 原因是假如用户访问了网站的其中一个网页，那么访问这个网站下的其它网页的概率将非常大。 在用户第一次访问后，这些页面公共代码的文件已经被浏览器缓存起来，在用户切换到其它页面时，存放公共代码的文件就不会再重新加载，而是直接从缓存中获取。 这样做后有如下好处：

- 减少网络传输流量，降低服务器成本；
- 虽然用户第一次打开网站的速度得不到优化，但之后访问其它页面的速度将大大提升。

**如何提取公共代码**

你已经知道了提取公共代码会有什么好处，但是在实战中具体要怎么做，以达到效果最优呢？ 通常你可以采用以下原则去为你的网站提取公共代码：

- 根据你网站所使用的技术栈，找出网站所有页面都需要用到的基础库，以采用 React 技术栈的网站为例，所有页面都会依赖 react、react-dom 等库，把它们提取到一个单独的文件。 一般把这个文件叫做 `base.js`，因为它包含所有网页的基础运行环境；
- 在剔除了各个页面中被 `base.js` 包含的部分代码外，再找出所有页面都依赖的公共部分的代码提取出来放到 `common.js` 中去。
- 再为每个网页都生成一个单独的文件，这个文件中不再包含  base.js  和  common.js  中包含的部分，而只包含各个页面单独需要的部分代码。

文件之间的结构图如下：

![图4-11 提取公共代码文件结构图](F:\Code\github\前端面试\assets\4-11提取公共代码.png)

读到这里你可以会有疑问：既然能找出所有页面都依赖的公共代码，并提取出来放到  common.js  中去，为什么还需要再把网站所有页面都需要用到的基础库提取到 base.js  去呢？ 原因是为了长期的缓存  base.js  这个文件。

发布到线上的文件都会采用在[4-9CDN加速](http://webpack.wuhaolin.cn/4%E4%BC%98%E5%8C%96/4-9CDN%E5%8A%A0%E9%80%9F.html)中介绍过的方法，对静态文件的文件名都附加根据文件内容计算出 Hash 值，也就是最终  base.js  的文件名会变成 base_3b1682ac.js ，以长期缓存文件。 网站通常会不断的更新发布，每次发布都会导致 `common.js` 和各个网页的 JavaScript 文件都会因为文件内容发生变化而导致其 Hash 值被更新，也就是缓存被更新。

把所有页面都需要用到的基础库提取到 `base.js` 的好处在于只要不升级基础库的版本，`base.js` 的文件内容就不会变化，Hash 值不会被更新，缓存就不会被更新。 每次发布浏览器都会使用被缓存的 `base.js` 文件，而不用去重新下载 `base.js` 文件。 由于 `base.js` 通常会很大，这对提升网页加速速度能起到很大的效果。

**如何通过 Webpack 提取公共代码**

你已经知道如何提取公共代码，接下来教你如何用 Webpack 实现。

Webpack 内置了专门用于提取多个 Chunk 中公共部分的插件  CommonsChunkPlugin ， CommonsChunkPlugin  大致使用方法如下：

[![复制代码](F:\Code\github\前端面试\assets\copycode-1553260624763.gif)](javascript:void(0);)

```
const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');
new CommonsChunkPlugin({
  // 从哪些 Chunk 中提取
  chunks: ['a', 'b'],
  // 提取出的公共部分形成一个新的 Chunk，这个新 Chunk 的名称
  name: 'common'
})
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

以上配置就能从网页 A 和网页 B 中抽离出公共部分，放到 common 中。

每个 CommonsChunkPlugin 实例都会生成一个新的 Chunk，这个新 Chunk 中包含了被提取出的代码，在使用过程中必须指定 `name` 属性，以告诉插件新生成的 Chunk 的名称。 其中 `chunks` 属性指明从哪些已有的 Chunk 中提取，如果不填该属性，则默认会从所有已知的 Chunk 中提取。Chunk 是一系列文件的集合，一个 Chunk 中会包含这个 Chunk 的入口文件和入口文件依赖的文件。

通过以上配置输出的 common Chunk 中会包含所有页面都依赖的基础运行库 react、react-dom，为了把基础运行库从 common 中抽离到 base 中去，还需要做一些处理。

首先需要先配置一个 Chunk，这个 Chunk 中只依赖所有页面都依赖的基础库以及所有页面都使用的样式，为此需要在项目中写一个文件 `base.js` 来描述 base Chunk 所依赖的模块，文件内容如下：

```
// 所有页面都依赖的基础库
import 'react';
import 'react-dom';
// 所有页面都使用的样式
import './base.css';
```

接着再修改 Webpack 配置，在 entry 中加入 base，相关修改如下：

```
module.exports = {
  entry: {
    base: './base.js'
  },
};
```

以上就完成了对新 Chunk base 的配置。

为了从 common 中提取出 base 也包含的部分，还需要配置一个 CommonsChunkPlugin，相关代码如下：

```
new CommonsChunkPlugin({
  // 从 common 和 base 两个现成的 Chunk 中提取公共的部分
  chunks: ['common', 'base'],
  // 把公共的部分放到 base 中
  name: 'base'
})
```

由于 common 和 base 公共的部分就是 base 目前已经包含的部分，所以这样配置后 common 将会变小，而 base 将保持不变。

以上都配置好后重新执行构建，你将会得到四个文件，它们分别是：

```
base.js：所有网页都依赖的基础库组成的代码；
common.js：网页A、B都需要的，但又不在 base.js 文件中出现过的代码；
a.js：网页 A 单独需要的代码；
b.js：网页 B 单独需要的代码。
```

为了让网页正常运行，以网页 A 为例，你需要在其 HTML 中按照以下顺序引入以下文件才能让网页正常运行：

```
<script src="base.js"></script>
<script src="common.js"></script>
<script src="a.js"></script>
```

以上就完成了提取公共代码需要的所有步骤。

针对 CSS 资源，以上理论和方法同样有效，也就是说你也可以对 CSS 文件做同样的优化。

以上方法可能会出现 `common.js` 中没有代码的情况，原因是去掉基础运行库外很难再找到所有页面都会用上的模块。 在出现这种情况时，你可以采取以下做法之一：

- CommonsChunkPlugin 提供一个选项 `minChunks`，表示文件要被提取出来时需要在指定的 Chunks 中最小出现最小次数。 假如  minChunks=2、chunks=['a','b','c','d'] ，任何一个文件只要在  ['a','b','c','d']  中任意两个以上的 Chunk 中都出现过，这个文件就会被提取出来。 你可以根据自己的需求去调整 minChunks 的值，minChunks 越小越多的文件会被提取到 `common.js` 中去，但这也会导致部分页面加载的不相关的资源越多； minChunks 越大越少的文件会被提取到 `common.js` 中去，但这会导致 `common.js` 变小、效果变弱。
- 根据各个页面之间的相关性选取其中的部分页面用 CommonsChunkPlugin 去提取这部分被选出的页面的公共部分，而不是提取所有页面的公共部分，而且这样的操作可以叠加多次。 这样做的效果会很好，但缺点是配置复杂，你需要根据页面之间的关系去思考如何配置，该方法不通用。本实例[提供项目完整代码](http://webpack.wuhaolin.cn/4-11%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81.zip)

 

### 项目中如何处理安全问题

计算机程序主要就是输入/输出，安全问题由此产生，凡是有输入的地方都可能带来安全风险。根据输入的数据类型，web应用主要有数值型、字符型、文件型。

要消除风险就要对输入的数据进行检查，对于Web应用来说，检查的位置主要是前端和后端。前端检查只能防止正常状况，没法防止使用工具、程序绕开检查直接把数据发送给服务器。

**输入检查**

防止输入注入型攻击。所有的输入数据都要检查，除了前端检查外，为防止使用工具、程序绕开前端检查直接把数据发送给服务器，后端也要检查所有输入数据。

依据产品文档的要求进行合法性检查，数值型，手机号，时间，邮箱等

检查文本型是否含控制字符，过滤掉控制字符

检查文本型的长度

URL字符串转义，使用urlencode函数处理

**文件上传**

防止文件注入型攻击。

1、文件上传目录设置成不可执行

2、判断文件类型。结合MIME type与文件扩展名，设置文件类型白名单。对于图片文件，可以利用图片库函数深层次检查是否真是图片。

3、重命名文件名。

4、文件服务器使用独立的域名。

**输出转义**

防止XSS(跨站脚本攻击)。向页面输出的文本型数据进行html encode(转义)，即是将一些html中的特殊字符转义成普通字符，比如 & 转义成 & ，< 转义成 < ，'与"都要转义。对应的函数：javascriptencode，php的htmlentities。

同理xml数据包里的字符串值使用xmlencode，json数据包的字符串值使用jsonencode转义。

**XSS处理**

XSS的本质是HTML注入，用户输入的数据被当成Html代码执行了。

1、cookie使用HttpOnly限制

使得在客户端的js代码不能读取cookie值，但是不能防止从HTTP header里得到cookie值。

2、输出文本HTML转义

对网页上显示的文本内容使用HtmlEncode转义。js函数：OWASP ESAPI中的encodeCharacter。其它的如xmlencode、jsonencode等转义函数。

3、检查输入的URL

输入的url添加上 http: 或者 https:，然后转义输出到网页端

4、对传入js函数的文本型参数值进行javascript转义

先进行javascript转义再进行HTML转义。

**总结如下**：



![img](https:////upload-images.jianshu.io/upload_images/8450546-6482406c6477ddbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)





![img](https:////upload-images.jianshu.io/upload_images/8450546-808a0479acfd1d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)



**SQL注入**

预防办法：数据与代码分离，即不用字符串拼凑SQL语句，使用SQL预处理方法(参数使用占位符 ?)。

**XST处理**

XST(跨站追踪)攻击，关闭Web 服务器的TRACE方法。

**CSRF攻击的防御**

通常需要防御CSRF(Cross-Site Request Forgeries)攻击的页面是用户登录、修改/删除确认、订单确认等添加新数据、修改数据的页面，此外此类页面必须使用POST方式提交。



![img](https:////upload-images.jianshu.io/upload_images/8450546-716223f5c5dc5ab3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)



**HTTP头注入**

替换HTTP头字符值中的换行符。

**Cookie安全**

Cookie仅保存SessionId值，设置HttpOnly属性为On，

**用户密码安全**

1、使用安全的bcrypt替代MD5，bcrypt会产生随机盐 salt

**权限控制**

1、SSO单点登录。OpenID系统

2、Spring Security的实现-基于角色的访问控制(Role-Based Access Control)RBAC

3、基于数据的访问控制。比如将用户Id、对象id修改成另一个存在的id，如果没有检查当前登录用户是否是参数对应的id用户，就会产生修改别的用户数据的问题，也即是越权访问。

4、OAuth授权。OAuth第三方开源库

5、SessionId。sessionid加密处理

### 项目中网络层的安全处理

**1、尽量使用https**

https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。

**2、不要传输明文密码**

不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh

 token去申请新的token。

**3、Post并不比Get安全**

事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。

**4、不要使用301跳转**

301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。

**5、http请求都带上MAC（消息认证码）**

所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication

Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request

params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。

**6、http请求使用临时密钥**

高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES

 key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES

key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。

**7、AES使用CBC模式**

不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。

### 怎么实现this对象的深拷贝

深拷贝的实现方式：
1.手动复制

这里的复制并不是对象=对象（obj2 = obj1，此为浅拷贝）

```
var obj1 = { a: 10, b: 20, c: 30 };
var obj2 = { a: obj1.a, b: obj1.b, c: obj1.c };
obj2.b = 100;
console.log(obj1);
// { a: 10, b: 20, c: 30 } <-- 沒被改到
console.log(obj2);
// { a: 10, b: 100, c: 30 }
```

2.Object.assign()拷贝
当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。

3.转化为JSON再转化回来
利用JSON.stringify()和JSON.parse();

```
var obj1 = { body: { a: 10 } };
var obj2 = JSON.parse(JSON.stringify(obj1));
```

4.使用Object.create()
使用Object.create可以达到深拷贝的效果

```
var obj = finalObj || {};    
  for (var i in initalObj) {        
    var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
    if(prop === obj) {            
      continue;
    }        
    if (typeof prop === 'object') {
      obj[i] = (prop.constructor === Array) ? [] : Object.create(prop);
    } else {
      obj[i] = prop;
    }
  }    
  return obj;
}
```


利用一些已经有的封装好的库函数实现深拷贝
5.利用jquery中的$.exten()函数可以实现深拷贝

6.lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝！

## 阿里-航旅事业部

#### 1. CSS 盒子模型，绝对定位和相对定位

1）清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法[方法](http://caibaojian.com/ali-mianshi.html)

[清除浮动的四种方式及其原理理解](https://blog.csdn.net/u012207345/article/details/78279961)

文字环绕排版，

高度塌陷

- BFC

- 利用clear样式
- 父元素结束标签之前插入清除浮动的块级元素
- 利用伪元素（clearfix）
- 利用overflow清除浮动

仅仅只在父级元素上添加了一个值为auto的overflow属性，父元素的高度立即被撑起，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染（严格讲，这和清除浮动没有一点关系，因为不存在哪个元素的浮动被清除，不纠结这个问题）。其实，这里的overflow值，还可以是除了"visible"之外的任何有效值，它们都能达到撑起父元素高度，清除浮动的目的。不过，有的值可能会带来副作用，比如，scroll值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。那它们是如何做到浮动清除的呢？

2）如何保持浮层水平垂直居中

3）position 和 display 的取值和各自的意思和用法

4）样式的层级关系，选择器优先级，样式冲突，以及抽离样式模块怎么写，说出思路，有无实践经验

#### 2. JavaScript 基础

1）JavaScript 里有哪些数据类型，解释清楚 null 和 undefined，解释清楚原始数据类型和引用数据类型。比如讲一下 `1` 和 `Number(1)` 的区别

2）将一下 prototype 是什么东西，原型链的理解，什么时候用 `prototype`

3）函数里的`this`什么含义，什么情况下，怎么用。

3）`apply` 和 `call` 什么含义，什么区别？什么时候用。

4）数组和对象有哪些原生方法，列举一下，分别是什么含义，比如链接两个数组用哪个方法，删除数组的质定项。

#### 3. JavaScript 的面向对象

1）[JS](http://caibaojian.com/javascript/) 模块包装格式都用过哪些，CommonJS、AMD、CMD、KMD。定义一个JS 模块代码，最精简的格式是怎样。

2）JS 怎么实现一个类。怎么实例化这个类。

3）是否了解自定义事件。[jQuery](http://caibaojian.com/jquery/)里的fire函数是什么意思，什么时候用。

4）说一下了解的js 设计模式，解释一下单例、工厂、观察者。

5）[ajax](http://caibaojian.com/t/ajax) 跨域有哪些方法，jsonp 的原理是什么，如果页面编码和被请求的资源编码不一致如何处理？

#### 4. 开源工具

1）是否了解开源的工具 bower、npm、yeoman、grunt、gulp，有无用过，有无写过，一个 npm 的包里的 package.[JSON](http://caibaojian.com/t/json) 具备的必要的字段都有哪些（名称、版本号，依赖）

2）fiddle、charles 有没有用过，什么时候用

3）会不会用 ps 扣图，png、jpg、gif 这些图片格式解释一下，分别什么时候用。是否了解webp

4）说一下你常用的命令行工具

5）会不会用git，说上来几个命令，说一下git和svn的区别，有没有用git解决过冲突

#### 5. 计算机基础

1）说一下网络五层模型（HTTP协议从应用层到底层都基于哪些协议），HTTP 协议头字段说上来几个，缓存字段是怎么定义的，http和https的区别，在具体使用的时候有什么不一样。是否尽可能详细的掌握HTTP协议。

2）cookies 是干嘛的，服务器和浏览器之间的 cookies 是怎么传的，httponly 的 cookies 和可读写的 cookie 有什么区别，有无长度限制

3）从敲入 URL 到渲染完成的整个过程，包括 DOM 构建的过程，说的约详细越好。

4）是否了解[web](http://caibaojian.com/c/web)注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度。

5）是否了解公钥加密和私钥加密。如何确保表单提交里的密码字段不被泄露。验证码是干嘛的，是为了解决什么安全问题。

6）编码常识：文件编码、URL 编码、Unicode编码 什么含义。一个gbk编码的页面如何正确引用一个utf8的的资源

#### 6. 考察学习能力和方法

1）你每天必须登录的网站（前端技术相关）是什么？

2）前端技术方面看过哪些书，有无笔记，都有哪些收获。

3）收藏了哪些代码片段？

4）怎么理解前端技术的大趋势？自己再做哪方面的知识储备？

5）是否了解或精通其他（后端）的编程语言？

6）做过的项目有没有什么（视觉、交互）美感？什么是美？你觉得让你自己赏心悦目的网站或应用有哪些？

7）做项目有没有遇到哪些印象深刻的技术攻关，具体遇到什么问题，怎么找答案的，最后怎么解的。

来源：

前端开发博客

## 网易

### 介绍redux，主要解决什么问题
### 文件上传如何做断点续传

思路很简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕。

以下文字没有完整的代码，只有基础理论，伸手党绕道。

**读取文件**

```
var input = document.querySelector('input');
input.addEventListener('change', function() {
    var file = this.files[0];
});
```

**文件唯一性**

```
var md5code = md5(file);
```

**文件切割**

```
var reader = new FileReader();
reader.readAsArrayBuffer(file);
reader.addEventListener("load", function(e) {
    //每10M切割一段,这里只做一个切割演示，实际切割需要循环切割，
    var slice = e.target.result.slice(0, 10*1024*1024);
});
```

**h5上传一个（一片）文件**

```
var formdata = new FormData();
formdata.append('0', slice);
//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案
formdata.append('filename', file.filename);
var xhr = new XMLHttpRequest();
xhr.addEventListener('load', function() {
    //xhr.responseText
});
xhr.open('POST', '');
xhr.send(formdata);
xhr.addEventListener('progress', updateProgress);
xhr.upload.addEventListener('progress', updateProgress);

function updateProgress(event) {
    if (event.lengthComputable) {
        //进度条
    }
}
```

**无法获取文件类型的设备解决方案**

> 首先在：[http://www.garykessler.net/li...](http://www.garykessler.net/library/file_sigs.html%E6%9F%A5%E6%89%BE%E5%AF%B9%E5%BA%94%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%B4%E4%BF%A1%E6%81%AF)
> 这里只给出了常见的图片和视频的文件类型判断

```
function checkFileType(type, file, back) {
    /**
     * type png jpg mp4 ...
     * file input.change=> this.files[0]
     * back callback(boolean)
     */
    // http://www.garykessler.net/library/file_sigs.html
    var args = arguments;
    if (args.length != 3) {
        back(0);
    }
    var type = args[0]; // type = '(png|jpg)' , 'png'
    var file = args[1];
    var back = typeof args[2] == 'function' ? args[2] : function() {};
    if (file.type == '') {
        // 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型
        var imgType = [
            'ff d8 ff', //jpg
            '89 50 4e', //png

            '0 0 0 14 66 74 79 70 69 73 6F 6D', //mp4
            '0 0 0 18 66 74 79 70 33 67 70 35', //mp4
            '0 0 0 0 66 74 79 70 33 67 70 35', //mp4
            '0 0 0 0 66 74 79 70 4D 53 4E 56', //mp4
            '0 0 0 0 66 74 79 70 69 73 6F 6D', //mp4

            '0 0 0 18 66 74 79 70 6D 70 34 32', //m4v
            '0 0 0 0 66 74 79 70 6D 70 34 32', //m4v

            '0 0 0 14 66 74 79 70 71 74 20 20', //mov
            '0 0 0 0 66 74 79 70 71 74 20 20', //mov
            '0 0 0 0 6D 6F 6F 76', //mov

            '4F 67 67 53 0 02', //ogg
            '1A 45 DF A3', //ogg

            '52 49 46 46 x x x x 41 56 49 20', //avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54)
        ];
        var typeName = [
            'jpg',
            'png',
            'mp4',
            'mp4',
            'mp4',
            'mp4',
            'mp4',
            'm4v',
            'm4v',
            'mov',
            'mov',
            'mov',
            'ogg',
            'ogg',
            'avi',
        ];
        var sliceSize = /png|jpg|jpeg/.test(type) ? 3 : 12;
        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.addEventListener("load", function(e) {
            var slice = e.target.result.slice(0, sliceSize);
            reader = null;
            if (slice && slice.byteLength == sliceSize) {
                var view = new Uint8Array(slice);
                var arr = [];
                view.forEach(function(v) {
                    arr.push(v.toString(16));
                });
                view = null;
                var idx = arr.join(' ').indexOf(imgType);
                if (idx > -1) {
                    back(typeName[idx]);
                } else {
                    arr = arr.map(function(v) {
                        if (i > 3 && i < 8) {
                            return 'x';
                        }
                        return v;
                    });
                    var idx = arr.join(' ').indexOf(imgType);
                    if (idx > -1) {
                        back(typeName[idx]);
                    } else {
                        back(false);
                    }

                }
            } else {
                back(false);
            }

        });
    } else {
        var type = file.name.match(/\.(\w+)$/)[1];
        back(type);
    }
}
```

 **调用方法**

```
checkFileType('(mov|mp4|avi)',file,function(fileType){
    // fileType = mp4,
    // 如果file的类型不在枚举之列，则返回false
});
```

**上面上传文件的一步，可以改成：**

```
formdata.append('filename', md5code+'.'+fileType);
```

总结：有了切割上传，有了文件唯一标识信息（文件md5）断点续传只不过是后台的一个小小的判断逻辑而已。

**未来，前端，大有可为**

------

有些小伙伴不是太清楚后台的小小的判断是怎么做的：
这里贴一张图给大家参考，自己手画，有点丑，将就下。

![clipboard.png](F:\Code\github\前端面试\assets\4095867158-5ac2049c8e1d6_articlex.png)

后续我再画一张完整的上传流程图给更新上来。

### 表单可以跨域吗

不存在！

ajax跨域是因为浏览器需要保护用户的安全和隐私而给js设定的限制

from表单可以跨域一个是历史原因要保持兼容，一个是from表单刷新页面不会把结果返回给js

### promise、async有什么区别

 

### 搜索请求如何处理（防抖）

函数防抖就是函数在频繁需要触发情况时，只有等足够空闲的时间才去执行一次

比如我们在做搜索框的时候，要根据搜索的内容进行请求查找出相关的内容，此时我们在给输入框绑定oninput事件而不做防抖处理的话，每输入一个字就会进行一次处理。比如我想搜索abc，那就会输入a的时候触发请求数据一次，ab的时候触发请求数据一次，然后才是abc，但往往前两次是不需要的，而且频繁的进行请求也会影响性能，此时我们就需要进行防抖处理。

### 搜索请求中文如何请求

**<1>encodeURI与 decodeURI** 
应该是最常用的

```
encodeURI("啊哈嘿");
结果为:%E5%95%8A%E5%93%88%E5%98%BF
百度搜索就是get请求，比如空格就是%20，多打几个空格搜索看看。 
```

百度搜索就是get请求，比如空格就是%20，多打几个空格搜索看看。 

而且chrome+tomcat测试服务器接收自动转回来。

**<2> 修改服务器编码集(一劳永逸)**

Tomcat为例 
打开 server.xml

```
<Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="utf-8"/>
```


比较常用的方法

**<3>服务器转码(不推荐)**

```
String param = new String(param.getBytes("iso-8859-1"),"utf-8")
```

**<4>Base64 加密**

使用base64.js之类的脚本进行加密，服务端接收数据后解密。

介绍观察者模式

### 介绍中介者模式

中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。

简单来讲，就是设置一个中间平台，一切操作由中间平台去分发。

抽象中介者对象保存交互者，所以添加Register和UnRegister方法来对该列表进行管理，然后在具体中介者类中修改AWin和BWin方法，遍历列表，改变中介者和交互者的状态。

这样的设计还是存在一个问题——即增加一个新交互者时，此时虽然解决了抽象中介者类不需要修改的问题，但此时还是不得不去修改具体中介者类，即添加CWin方法，我们可以采用状态模式来解决这个问题

**中介者模式的优缺点**

**优点：**

- 简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。
- 提供系统的灵活性，使得各个同事对象独立而易于复用。

**缺点：**

- 中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。
- 新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。

**中介者模式的适用场景**

以下情况下可以考虑使用中介者模式：

- 一组定义良好的对象，现在要进行复杂的相互通信。
- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

### 观察者和订阅者发布的区别，各自用在哪里

在翻阅资料的时候，有人把观察者（Observer）模式等同于发布（Publish）/订阅（Subscribe）模式，也有人认为这两种模式还是存在差异，而我认为确实是存在差异的，本质上的区别是调度的地方不同。

**观察者模式**

比较概念的解释是，目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。

比如有个“天气中心”的具体目标A，专门监听天气变化，而有个显示天气的界面的观察者B，B就把自己注册到A里，当A触发天气变化，就调度B的更新方法，并带上自己的上下文。

![img](F:\Code\github\前端面试\assets\555379-20160313183429007-1351424959.png)

**发布/订阅模式**

比较概念的解释是，订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。

比如有个界面是实时显示天气，它就订阅天气事件（注册到调度中心，包括处理程序），当天气变化时（定时获取数据），就作为发布者发布天气信息到调度中心，调度中心就调度订阅者的天气处理程序。

![img](F:\Code\github\前端面试\assets\555379-20160313183439366-1623019133.png)

**总结**

1. 从两张图片可以看到，最大的区别是调度的地方。

虽然两种模式都存在订阅者和发布者（具体观察者可认为是订阅者、具体目标可认为是发布者），但是观察者模式是由具体目标调度的，而发布/订阅模式是统一由调度中心调的，所以观察者模式的订阅者与发布者之间是存在依赖的，而发布/订阅模式则不会。

2. 两种模式都可以用于松散耦合，改进代码管理和潜在的复用。



### 介绍react优化

### 介绍http2.0

**1、什么是HTTP2.0**

HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于**SPDY协议**（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。

**2、与HTTP 1.1相比，主要区别包括**

1. HTTP/2采用二进制格式而非文本格式
2. HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
3. 使用报头压缩，HTTP/2降低了开销
4. HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

**3、HTTP/2为什么是二进制？**

比起像HTTP/1.x这样的文本协议，二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

**4、为什么 HTTP/2 需要多路传输?**

HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。所以客户端只需要一个连接就能加载一个页面。

**5、消息头为什么需要压缩?**

假定一个页面有80个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1400字节的消息头（着同样也并不少见，因为Cookie和引用等东西的存在）, 至少要7到8个来回去“在线”获得这些消息头。这还不包括响应时间——那只是从客户端那里获取到它们所花的时间而已。这全都由于TCP的慢启动机制，它会基于对已知有多少个包，来确定还要来回去获取哪些包 – 这很明显的限制了最初的几个来回可以发送的数据包的数量。相比之下，即使是头部轻微的压缩也可以是让那些请求只需一个来回就能搞定——有时候甚至一个包就可以了。这种开销是可以被节省下来的，特别是当你考虑移动客户端应用的时候，即使是良好条件下，一般也会看到几百毫秒的来回延迟。

**6、服务器推送的好处是什么？**

当浏览器请求一个网页时，服务器将会发回HTML，在服务器开始发送JavaScript、图片和CSS前，服务器需要等待浏览器解析HTML和发送所有内嵌资源的请求。服务器推送服务通过“推送”那些它认为客户端将会需要的内容到客户端的缓存中，以此来避免往返的延迟。

 

### 通过什么做到并发请求

使用异步`Prmosie`或者`web worker`

### http1.1时如何复用tcp连接



### 介绍service worker

Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。由于PWA是谷歌提出，那么对ServiceWorker，同样也提出一些能力要求：

- 后台消息传递
- **网络代理，转发请求，伪造响应**
- **离线缓存**
- 消息推送

　　在目前阶段，ServiceWorker的主要能力集中在网络代理和离线缓存上。具体的实现上，可以理解为ServiceWorker是一个能在网页关闭时仍然运行的WebWorker。

##### ServiceWorker的生命周期

　　刚才讲到ServiceWorker拥有离线能力的WebWorker，既然这么强的能力，那就需要好好管理起来。所以我们要明白ServiceWorker的生命周期，也就是它从创建到销毁的过程。在所有介绍ServiceWorker生命周期的文章中最常见的就是下面这张图。

![img](F:\Code\github\前端面试\assets\412020-20171216185832389-867345604.png)

　　整个过程中一个ServiceWorker会经历：安装、激活、等待、销毁的阶段。但实际上这张图我感觉并没有清晰的解释ServiceWorker的声明周期，所以我制作了下面这张图。

![img](F:\Code\github\前端面试\assets\412020-20171216190325077-715109184.png)

### 介绍css3中position:sticky

position属性中最有意思的就是sticky了，设置了sticky的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。

　　可以知道sticky属性有以下几个特点：

- 该元素并不脱离文档流，仍然保留元素原本在文档流中的位置。
- 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。
- 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量

　　比较蛋疼的是这个属性的兼容性还不是很好，目前仍是一个试验性的属性，并不是W3C推荐的标准。它之所以会出现，也是因为监听`scroll`事件来实现粘性布局使浏览器进入慢滚动的模式，这与浏览器想要通过硬件加速来提升滚动的体验是相悖的。

简单的说，要让sticky属性生效的条件有以下两点：

- 一个是元素自身在文档流中的位置
- 另一个是该元素的父容器的边缘

　　第一点上面已经讲过了，如果设置了top: 50px，那么元素在达到距离顶部50px时才会发生定位，否则并不会发生定位。

　　第二点则需要考虑父容器的高度情况：sticky元素在到达父容器的底部时，则不会再发生定位，如果父容器高度并没有比sticky元素高，那么sticky元素一开始就达到了底部，并不会有定位的效果。

　　此外还有一点就是父元素的overflow属性，如果父元素的overflow属性并不是默认的visible属性，那么sticky元素则相对于该父元素定位。也就是如果要定位在顶部的话，此时这个效果就无效了。。。

### redux请求中间件如何处理并发



### 介绍Promise，异常捕获
### 介绍position属性包括CSS3新增
### 浏览器事件流向



### 介绍事件代理以及优缺点



### React组件中怎么做事件代理



### React组件事件代理的原理
### 介绍this各种情况
### 前端怎么控制管理路由
### 使用路由时出现问题如何解决
### React怎么做数据的检查和变化

## 滴滴

### react-router怎么实现路由切换
### react-router里的`<Link>`标签和`<a>`标签有什么区别
### <a>标签默认事件禁掉之后做了什么才实现了跳转
### React层面的性能优化
### 整个前端性能提升大致分几类
### `import { Button } from 'antd'`，打包的时候只打包`button`，分模块加载，是怎么做到的
### 使用`import`时，`webpack`对`node_modules`里的依赖会做什么
### JS异步解决方案的发展历程以及优缺点
### Http报文的请求会有几个部分
### `cookie`放哪里，`cookie`能做的事情和存在的价值
### `cookie`和`token`都存放在`header`里面，为什么只劫持前者
### `cookie`和`session`有哪些方面的区别
### `React`中`Dom`结构发生变化后内部经历了哪些变化
### `React`挂载的时候有3个组件，textComponent、composeComponent、domComponent，区别和关系，Dom结构发生变化时怎么区分data的变化，怎么更新，更新怎么调度，如果更新的时候还有其他任务存在怎么处理
### key主要是解决哪一类的问题，为什么不建议用索引index（重绘）
### Redux中异步的请求怎么处理
### Redux中间件是什么东西，接受几个参数（两端的柯里化函数）
### 柯里化函数两端的参数具体是什么东西
### 中间件是怎么拿到store和action，然后怎么处理
### state是怎么注入到组件的，从reducer到组件经历了什么样的过程
### koa中response.send、response.rounded、response.json发生了什么事，浏览器为什么能识别到它是一个json结构或是html
### koa-bodyparser怎么来解析request
### webpack整个生命周期，loader和plugin有什么区别
### 介绍AST（Abstract Syntax Tree）抽象语法树
### 安卓Activity之间数据是怎么传递的
### 安卓4.0到6.0过程中WebView对js兼容性的变化
### WebView和原生是如何通信
### 跨域怎么解决，有没有使用过Apache等方案

## 今日头条

### 对async、await的理解，内部原理 
### 介绍下Promise，内部实现 
### 清除浮动  
### 定位问题（绝对定位、相对定位等） 
### 从输入URL到页面加载全过程 
### tcp3次握手 
### tcp属于哪一层（1 物理层 ###> 2 数据链路层 ###> 3 网络层(ip)###> 4 传输层(tcp) ###> 5 应用层(http)） 
### redux的设计思想 
### 接入redux的过程 
### 绑定connect的过程 
### connect原理 
### webpack介绍 
### == 和 ===的区别，什么情况下用相等== 
### bind、call、apply的区别 
### 动画的了解 
### 介绍下原型链（解决的是继承问题吗） 
### 对跨域的了解 

## 有赞

### Linux 754 介绍
### 介绍冒泡排序，选择排序，冒泡排序如何优化
### transform动画和直接使用left、top改变位置有什么优缺点
### 如何判断链表是否有环
### 介绍二叉搜索树的特点
### 介绍暂时性死区
### ES6中的map和原生的对象有什么区别
### 观察者和发布###订阅的区别
### react异步渲染的概念,介绍Time Slicing 和 Suspense
### 16.X声明周期的改变
### 16.X中props改变后在哪个生命周期中处理
### 介绍纯函数
### 前端性能优化
### pureComponent和FunctionComponent区别
### 介绍JSX
### 如何做RN在安卓和IOS端的适配
### RN为什么能在原生中绘制成原生组件（bundle.js）
### 介绍虚拟DOM
### 如何设计一个localStorage，保证数据的实效性
### 如何设计Promise.all()
### 介绍高阶组件
### sum(2, 3)实现sum(2)(3)的效果
### react性能优化
### 两个对象如何比较

## 挖财

### JS的原型
### 变量作用域链
### call、apply、bind的区别
### 防抖和节流的区别
### 介绍各种异步方案
### react生命周期
### 介绍Fiber
### 前端性能优化
### 介绍DOM树对比
### react中的key的作用
### 如何设计状态树
### 介绍css，xsrf
### http缓存控制
### 项目中如何应用数据结构
### native提供了什么能力给RN
### 如何做工程上的优化
### `shouldComponentUpdate`是为了解决什么问题
### 如何解决props层级过深的问题
### 前端怎么做单元测试
### webpack生命周期
### webpack打包的整个过程
### 常用的plugins
### pm2怎么做进程管理，进程挂掉怎么处理
### 不用pm2怎么做进程管理

## 沪江

### 介绍下浏览器跨域
### 怎么去解决跨域问题
### jsonp方案需要服务端怎么配合
### Ajax发生跨域要设置什么（前端）
### 加上CORS之后从发起到请求正式成功的过程
### xsrf跨域攻击的安全性问题怎么防范
### 使用Async会注意哪些东西
### Async里面有多个await请求，可以怎么优化（请求是否有依赖）
### Promise和Async处理失败的时候有什么区别
### Redux在状态管理方面解决了React本身不能解决的问题
### Redux有没有做过封装
### react生命周期，常用的生命周期 
### 对应的生命周期做什么事 
### 遇到性能问题一般在哪个生命周期里解决 
### 怎么做性能优化（异步加载组件...）
### 写react有哪些细节可以优化 
### React的事件机制（绑定一个事件到一个组件上）
### 介绍下事件代理，主要解决什么问题
### 前端开发中用到哪些设计模式
### React/Redux中哪些功能用到了哪些设计模式
### JS变量类型分为几种，区别是什么
### JS里垃圾回收机制是什么，常用的是哪种，怎么处理的
### 一般怎么组织CSS（Webpack）

## 饿了么

### 小程序里面开页面最多多少
### React子父组件之间如何传值
### Emit事件怎么发，需要引入什么
### 介绍下React高阶组件，和普通组件有什么区别
### 一个对象数组，每个子对象包含一个id和name，React如何渲染出全部的name
### 在哪个生命周期里写
### 其中有几个name不存在，通过异步接口获取，如何做
### 渲染的时候key给什么值，可以使用index吗，用id好还是index好
### webpack如何配sass，需要配哪些loader
### 配css需要哪些loader
### 如何配置把js、css、html单独打包成一个文件
### div垂直水平居中（flex、绝对定位）
### 两个元素块，一左一右，中间相距10像素
### 上下固定，中间滚动布局如何实现
### [1, 2, 3, 4, 5]变成[1, 2, 3, a, b, 5]
### 取数组的最大值（ES5、ES6）
### apply和call的区别
### ES5和ES6有什么区别
### some、every、find、filter、map、forEach有什么区别
### 上述数组随机取数，每次返回的值都不一样
### 如何找0-5的随机数，95-99呢
### 页面上有1万个button如何绑定事件
### 如何判断是button
### 页面上生成一万个button，并且绑定事件，如何做（JS原生操作DOM）
### 循环绑定时的index是多少，为什么，怎么解决
### 页面上有一个input，还有一个p标签，改变input后p标签就跟着变化，如何处理
### 监听input的哪个事件，在什么时候触发

## 携程

### 对React看法，有没有遇到一些坑
### 对闭包的看法，为什么要用闭包
### 手写数组去重函数
### 手写数组扁平化函数
### 介绍下Promise的用途和性质
### Promise和Callback有什么区别
### React生命周期
### 两道手写算法题

## 喜马拉雅

### ES6新的特性
### 介绍Promise
### Promise有几个状态
### 说一下闭包
### React的生命周期
### componentWillReceiveProps的触发条件是什么
### React16.3对生命周期的改变
### 介绍下React的Filber架构
### 画Filber渲染树
### 介绍React高阶组件
### 父子组件之间如何通信
### Redux怎么实现属性传递，介绍下原理
### React-Router版本号
### 网站SEO怎么处理
### 介绍下HTTP状态码
### 403、301、302是什么
### 缓存相关的HTTP请求头
### 介绍HTTPS
### HTTPS怎么建立安全通道
### 前端性能优化（JS原生和React）
### 用户体验做过什么优化
### 对PWA有什么了解
### 对安全有什么了解
### 介绍下数字签名的原理
### 前后端通信使用什么方案
### RESTful常用的Method
### 介绍下跨域
### Access-Control-Allow-Origin在服务端哪里配置
### csrf跨站攻击怎么解决
### 前端和后端怎么联调

## 兑吧

### localStorage和cookie有什么区别
### CSS选择器有哪些
### 盒子模型，以及标准情况和IE下的区别
### 如何实现高度自适应
### prototype和`——proto——`区别
### `_construct`是什么
### `new`是怎么实现的
### promise的精髓，以及优缺点
### 如何实现H5手机端的适配
### `rem`、`flex`的区别（root em）
### `em`和`px`的区别
### React声明周期
### 如何去除url中的#号
### Redux状态管理器和变量挂载到window中有什么区别
### webpack和gulp的优缺点
### 如何实现异步加载
### 如何实现分模块打包（多入口）
### 前端性能优化（1js css；2 图片；3 缓存预加载； 4 SSR； 5 多域名加载；6 负载均衡）
### 并发请求资源数上限（6个）
### base64为什么能提升性能，缺点
### 介绍webp这个图片文件格式
### 介绍koa2
### Promise如何实现的
### 异步请求，低版本fetch如何低版本适配
### ajax如何处理跨域
### CORS如何设置
### jsonp为什么不支持post方法
### 介绍同源策略
### React使用过的一些组件
### 介绍Immuable
### 介绍下redux整个流程原理
### 介绍原型链
### 如何继承

## 微医

### 介绍JS数据类型，基本数据类型和引用数据类型的区别
### Array是Object类型吗
### 数据类型分别存在哪里
### `var a  = {name: "前端开发"}; var b = a; a = null`那么b输出什么
### `var a = {b: 1}`存放在哪里
### `var a = {b: {c: 1}}`存放在哪里
### 栈和堆的区别
### 垃圾回收时栈和堆的区别
### 数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少
### 栈和堆具体怎么存储
### 介绍闭包以及闭包为什么没清除
### 闭包的使用场景
### JS怎么实现异步
### 异步整个执行周期
### Promise的三种状态
### Async/Await怎么实现
### Promise和setTimeout执行先后的区别
### JS为什么要区分微任务和宏任务
### Promise构造函数是同步还是异步执行，then呢
### 发布###订阅和观察者模式的区别
### JS执行过程中分为哪些阶段
### 词法作用域和this的区别
### 平常是怎么做继承
### 深拷贝和浅拷贝
### loadsh深拷贝实现原理
### ES6中`let`块作用域是怎么实现的
### React中`setState`后发生了什么
### `setState`为什么默认是异步
### `setState`什么时候是同步的
### 为什么3大框架出现以后就出现很多native（RN）框架（虚拟DOM）
### 虚拟DOM主要做了什么
### 虚拟DOM本身是什么（JS对象）
### 304是什么
### 打包时Hash码是怎么生成的
### 随机值存在一样的情况，如何避免
### 使用webpack构建时有无做一些自定义操作
### webpack做了什么
### a，b两个按钮，点击aba，返回顺序可能是baa，如何保证是aba（Promise.then）
### `node`接口转发有无做什么优化
### `node`起服务如何保证稳定性，平缓降级，重启等
### RN有没有做热加载
### RN遇到的兼容性问题
### RN如何实现一个原生的组件
### RN混原生和原生混RN有什么不同
### 什么是单页项目
### 遇到的复杂业务场景
### Promise.all实现原理

## 寺库

### 介绍Promise的特性，优缺点
### 介绍Redux
### RN的原理，为什么可以同时在安卓和IOS端运行
### RN如何调用原生的一些功能
### 介绍RN的缺点
### 介绍排序算法和快排原理
### 堆和栈的区别
### 介绍闭包
### 闭包的核心是什么
### 网络的五层模型
### HTTP和HTTPS的区别
### HTTPS的加密过程
### 介绍SSL和TLS
### 介绍DNS解析
### JS的继承方法
### 介绍垃圾回收
### cookie的引用为了解决什么问题
### cookie和localStorage的区别
### 如何解决跨域问题
### 前端性能优化

## 宝宝树

### 使用canvas绘图时如何组织成通用组件
### formData和原生的ajax有什么区别
### 介绍下表单提交，和formData有什么关系
### 介绍redux接入流程
### rudux和全局管理有什么区别（数据可控、数据响应）
### RN和原生通信
### 介绍MVP怎么组织
### 介绍异步方案
### promise如何实现then处理
### koa2中间件原理
### 常用的中间件
### 服务端怎么做统一的状态处理
### 如何对相对路径引用进行优化
### node文件查找优先级
### npm2和npm3+有什么区别

## 海康威视

### knex连接数据库响应回调
### 介绍异步方案
### 如何处理异常捕获
### 项目如何管理模块
### 前端性能优化
### JS继承方案
### 如何判断一个变量是不是数组
### 变量a和b，如何交换
### 事件委托
### 多个<li>标签生成的Dom结构是一个类数组
### 类数组和数组的区别
### dom的类数组如何转成数组
### 介绍单页面应用和多页面应用
### redux状态树的管理
### 介绍localstorage的API

## 蘑菇街

### html语义化的理解
### `<b>`和`<strong>`的区别
### 对闭包的理解
### 工程中闭包使用场景
### 介绍this和原型
### 使用原型最大的好处
### react设计思路
### 为什么虚拟DOM比真实DOM性能好
### react常见的通信方式
### redux整体的工作流程
### redux和全局对象之间的区别
### Redux数据回溯设计思路
### 单例、工厂、观察者项目中实际场景
### 项目中树的使用场景以及了解
### 工作收获

## 酷家乐

### react生命周期
### react性能优化
### 添加原生事件不移除为什么会内存泄露
### 还有哪些地方会内存泄露
### setInterval需要注意的点
### 定时器为什么是不精确的
### setTimeout(1)和setTimeout(2)之间的区别
### 介绍宏任务和微任务
### promise里面和then里面执行有什么区别
### 介绍pureComponet
### 介绍Function Component
### React数据流
### props和state的区别
### 介绍react context
### 介绍class和ES5的类以及区别
### 介绍箭头函数和普通函数的区别
### 介绍defineProperty方法，什么时候需要用到
### for..in 和 object.keys的区别
### 介绍闭包，使用场景
### 使用闭包特权函数的使用场景
### get和post有什么区别

## 百分点

### React15/16.x的区别
### 重新渲染render会做些什么
### 哪些方法会触发react重新渲染
### state和props触发更新的生命周期分别有什么区别
### setState是同步还是异步
### 对无状态组件的理解
### 介绍Redux工作流程
### 介绍ES6的功能
### let、const以及var的区别
### 浅拷贝和深拷贝的区别
### 介绍箭头函数的this
### 介绍Promise和then
### 介绍快速排序
### 算法：前K个最大的元素

## 海风教育 

### 对react看法，它的优缺点 

### 使用过程中遇到的问题，如何解决的 

### react的理念是什么（拿函数式编程来做页面渲染）

### JS是什么范式语言(面向对象还是函数式编程)

### koa原理，为什么要用koa(express和koa对比) 

### 使用的koa中间件 

### ES6使用的语法 

### Promise 和 async/await 和 callback的区别 

### Promise有没有解决异步的问题（promise链是真正强大的地方）

### Promise和setTimeout的区别（Event Loop）

### 进程和线程的区别（一个node实例就是一个进程，node是单线程，通过事件循环来实现异步 

  ）

### 介绍下DFS深度优先 

### 介绍下观察者模式 

### 观察者模式里面使用的数据结构(不具备顺序 ，是一个list)