# 浏览器缓存、HTTP缓存（强缓存、协商缓存），浏览器缓存和CDN的关系

>  转载至http://www.cnblogs.com/blogbyhuer/p/9335257.html

### 一、CDN的定义

CDN：Content Delivery Network/Content Ddistribute Network，即内容分发网络

客户端访问网站的过程：

没有CDN：

1、用户在浏览器访问栏中输入要访问的域名；

2、浏览器向DNS服务器请求对该域名的解析；

3、DNS服务器返回该域名的IP地址给浏览器

4、浏览器使用该IP地址向服务器请求内容。

5、服务器将用户请求的内容返回给浏览器。

使用了CDN：

1、用户在浏览器中输入要访问的域名。

2、浏览器向DNS服务器请求对域名进行解析。由于CDN对域名解析进行了调整，DNS服务器会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。

3、CDN的DNS服务器将CDN的负载均衡设备IP地址返回给用户。

4、用户向CDN的负载均衡设备发起内容URL访问请求。

5、CDN负载均衡设备会为用户选择一台合适的缓存服务器提供服务。

选择的依据包括：根据用户IP地址，判断哪一台服务器距离用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器的负载情况，判断哪一台服务器的负载较小。

基于以上这些依据的综合分析之后，负载均衡设置会把缓存服务器的IP地址返回给用户。

6、用户向缓存服务器发出请求。

7、缓存服务器响应用户请求，将用户所需内容传送到用户。

如果这台缓存服务器上并没有用户想要的内容，而负载均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉取到本地。

### 二、关于缓存

没有CDN：浏览器缓存

使用了CDN：浏览器缓存+CDN缓存

在用户第一次访问网站后，网站的一些静态资源如图片等就会被下载到本地，作为缓存，当用户第二次访问该网站的时候，浏览器就会从缓存中加载资源，不用向服务器请求资源，从而提高了网站的访问速度，而若使用了CDN，当浏览器本地缓存的资源过期之后，浏览器不是直接向源站点请求资源，而是向CDN边缘节点请求资源，CDN边缘节点中也存在缓存，若CDN中的缓存也过期，那就由CDN边缘节点向源站点发出回源请求来获取最新资源。

**浏览器缓存以及CDN缓存都有一套判断文件是否需要更新的机制：**

浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器，当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器还是从自己的缓存中加载资源，当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

CDN节点缓存机制在不同服务商中是不同的，但一般都遵循HTTP协议，通过http响应头中的Cache-Control:max-age的字段来设置CDN节点文件缓存时间。当客户端向CDN节点请求数据时，CDN会判断缓存数据是否过期，若没有过期，则直接将缓存数据返回给客户端，否则就向源站点发出请求，从源站点拉取最新数据，更新本地缓存，并将最新数据返回给客户端。CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。CDN缓存时间会对“回源率”产生直接的影响，若CDN缓存时间短，则数据经常失效，导致频繁回源，增加了源站的负载，同时也增大了访问延时；若缓存时间长，数据更新时间慢，因此需要针对不同的业务需求来选择特定的数据缓存管理。

浏览器缓存刷新：

1、在地址栏中输入网址后按回车或者点击转到按钮

浏览器以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存即使用强缓存，从而减少了对服务器的请求，Expires、max-age标志只对这种方式有效。

2、按F5或浏览器刷新按钮

浏览器会在请求中附加必要的缓存协商，但不允许浏览器直接使用本地缓存即跳过强缓存的判断，直接进行协商缓存的判断，Last-Modified、ETag在这种方式发挥作用。

3、按Ctrl+F5或按Ctrl并点击刷新按钮

强制刷新，完全不使用缓存

CDN缓存刷新：

CDN节点对开发者时透明的，可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN节点缓存的效果，强制使数据过期，从而获取到最新的数据。

### 三、浏览器缓存

这一点主要解析浏览器缓存以及缓存机制的详细过程。

**1.1强缓存：**

当浏览器对某个资源的请求命中了强缓存时，返回的http状态码为200，在chrome开发者工具中的network中的size会显示from cache

强缓存时利用Expires或者Cache-Control这两个http header实现的，都用来表示资源在客户端缓存的有效期

Expires是http1.0提出的一个header，描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如Exprires：Thu，31 Dec 2037 23：55：55 GMT

**缓存过程：**

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Expires的header

2、浏览器在接收到这个资源后，会把这个资源连同所有的response header一起缓存下来，所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header

3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。

4、如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新

Expires是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果，所以在http1.1的时候，提出了一个新的header，也就是**Cache-Control，这是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，因此更有效安全一些，在配置缓存的时候，以秒为单位，用数值表示：如：Cache-Control：max-age=315360000，它的缓存过程是：**

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header

2、浏览器在接收到这个资源的时候，会把这个资源连同所有response header一起缓存下来

3、浏览器再次请求这个资源的时候，先从缓存中寻找，找到这个资源之后，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。

4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control在重新加载的时候会被更新

这两个header可以只用一个，也可以同时用两个，同时存在时，Cache-Control优先级高于Expires

**1.2 强缓存的管理**

两种方式来设置是否启用强缓存：

1、通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header

2、通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header

**1.3 强缓存的应用**

强缓存是前端性能优化最有力的工具，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度，通常是为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户只会在第一次访问网站时加载静态资源，其他时间只要缓存没有失效并且用户没有强制刷新的条件下都会从缓存中加载。

然而这种缓存配置方式会带来一个问题，就是当资源更新时，客户端由于有缓存不会向服务器请求最新的资源，这个问题已有解决方案：

通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。

但要实现有更新的文件才需要浏览器重新加载，因此必须让url的修改与文件内容相关联，利用数据摘要算法对文件求摘要信息，摘要信息与文件内容一一对应，这一点许多前端构建工具都做到了，如webpack

**1.4 浏览器默认缓存使开发环境下常因为资源没有及时更新而看不到效果**

解决方法：

1、ctrl+F5

2、浏览器隐私模式开发

3、chrome开发者工具里将Disable cache选项打勾，阻止缓存

4、在开发阶段，给资源加上一个动态的参数，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非是在动态页面比如jsp里开发就可以用服务器变量来解决，或者用前端构建工具来处理这个参数修改的问题。

5、如果资源引用的页面被嵌入到了一个iframe里面，可以在iframe的区域右键重新加载该页面

6、如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数

7、动态设置iframe的src时，有可能因为缓存问题导致看不到最新效果，在src后面添加随机数即可

8、通过前端开发工具grunt gulp等的插件来启动一个静态服务器，则在这个服务器下所有资源返回的response header中，Cache-Control始终被设置为不缓存

**1.5 发布问题**

发布问题：若页面和它引用的资源路径同时更新了，不管是先部署页面还是先部署资源都会带来各种问题，这是由于资源是覆盖式发布的，即用待发布资源覆盖已发布资源。

解决办法就是实现非覆盖式发布：把有修改的资源文件作为一个新的文件发布，不对已有的资源文件进行覆盖，这样用户还可以请求旧的资源文件，不至于发生页面错乱的问题，这样先部署静态资源，再覆盖式部署页面，等到用户访问新页面的时候，新的资源文件也已发布，就可以正确请求，即可解决问题。

**2.1 协商缓存**

如果命中协商缓存，请求响应返回的http状态为304以及一个Not Modified字符串，协商缓存利用的是【Last-Modified、If-Modified-Since】、【ETag、If-None-Match】这两对header来管理的。

**【****Last-Modified、If-Modified-Since】：**

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源时，在response的header加上Last-Modified的header，表示这个资源在服务器上的最后修改时间

2、浏览器再次向服务器请求这个资源时，在request的header加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值

3、服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容，如果有变化就返回资源内容，当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为资源没有变化，Last-Modified的值也不变

4、浏览器收到304的响应后，就会从缓存中加载资源

5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modofied header在重新加载的时候会被更新，下次请求时，If-Modified-Since会采用上一次返回的Last-Modified的值

这一对header都是根据服务器时间返回的，有时候会有服务器资源有变化，但最后修改时间却没有变化的情况，因此有了

**【Etag、If-None-Match】：**

1、浏览器第一次向服务器请求一个资源，服务器在返回这个资源的同时，在response的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，是一个字符串，只要资源内容发生改变，这个字符串也会改变，跟时间没有关系

2、浏览器再次请求这个资源的时候，在request的header上加上If-None-Match的header。这个header的值是上一次请求返回的ETag的值

3、服务器再次收到资源请求时，根据客户端传过来的If-None-Match和重新生成的该资源的新的ETag做比较，相同则返回304 Not Modified，不会返回资源内容，如果不同则返回资源内容，但这里即使资源没有发生变化，也会返回ETag，因为这个ETag重新生成过，即使没有ETag没有变化

4、浏览器收到304响应后，就从缓存中加载资源

**2.2 协商缓存的管理**

一般服务器上的【Last-Modified、If-Modified-Since】和【Etag、If-None-Match】会同时启用，协商缓存需要配合强缓存使用

![img](F:\Code\github\浏览器\assets\13168254-20f172ed4bb05684.webp)

![img](F:\Code\github\浏览器\assets\13168254-9e0ff8040439a4ad.webp)



![img](F:\Code\github\浏览器\assets\13168254-eb220515b94bb946.webp)

强缓存阶段：先在本地查找该资源，如果发现该资源，并且其他限制也没有问题(比如:缓存有效时间)，就命中强缓存，返回200，直接使用强缓存，并且不会发送请求到服务器

弱缓存阶段：在本地缓存中找到该资源，发送一个http请求到服务器，服务器判断这个资源没有被改动过，则返回304，让浏览器使用该资源。

缓存失败阶段(重新请求)：当服务器发现该资源被修改过，或者在本地没有找到该缓存资源，服务器则返回该资源的数据。

### 强缓存与弱缓存的区别：

**获取资源形式**： 都是从缓存中获取资源的。

**状态码**： 强缓存返回200(from cache),弱缓存返回304状态码

**请求(最大区别)**：

强缓存不发送请求，直接从缓存中取。

弱缓存需要发送一个请求，验证这个文件是否可以使用（有没有被改动过）

**强缓存：**
强缓存是利用Expires或者Cache-Control，让原始服务器为文件设置一个过期时间，在多长时间内可以将这些内容视为最新的。

若时间未过期，则命中强缓存，使用缓存文件不发送请求。

**Cache-Control**
Cache-Control 是http1.1中为了弥补Expires的缺陷而加入的，当Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。

**选项：**

**可缓存性:**

public： 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。

private: 只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存。

no-cache: 强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。http请求没有减少，会减少一个响应体(文件内容),这种个选项类似弱缓存。

only-if-cached: 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。

**到期设置：**

max-age=60：设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。 这里是60秒

**其他设置：**

no-store: 告诉浏览器在任何情况下都不要进行cache，不在本地保留拷贝。

must-revalidate: 缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。

**更多设置，移动MDN**

    // 示例 
    Cache-Control: no-cache, no-store, must-revalidate
    Cache-Control:public, max-age=31536000
    Cache-Control: max-age=3600, must-revalidate
**http1.0时代的缓存 Expires+Pragma**
**Expires用于设置缓存到期时间：**

指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires，如果expires到期需要重新请求。

    Expires:Sat, 09 Jun 2018 08:13:56 GMT
    有一个问题是由于使用具体时间，如果时间表示出错或者没有转换到正确的时区都可能造成缓存生命周期出错。
**Pragma禁用缓存：**

Pragma : no-cache 表示防止客户端缓存，需要强制从服务器获取最新的数据；

    Pragma : no-cache  //只有这一个用法 禁用缓存，强制从服务器获取最新的数据； 
**强缓存命中 from memory cache & from disk cache**
在测试的时候，看到命中强缓存时，有两种状态，200 (from memory cache) cache & 200 (from disk cache)，于是去找了一下这两者的区别：

memory cache: 将资源存到内存中，从内存中获取。

disk cache：将资源缓存到磁盘中，从磁盘中获取。

二者最大的区别在于：当退出进程时，内存中的数据会被清空，而磁盘的数据不会。

更详细的介绍推荐这篇文章

**弱缓存：**
如果强缓存时间过期，或者没有设置，导致未命中的话。就进入到了弱缓存的阶段了，

**Last-Modified & if-modified-since:**

Last-Modified与If-Modified-Since是一对报文头，属于http 1.0。

last-modified是web服务器认为文件的最后修改时间，last-modified是第一次请求文件的时候，服务器返回的一个属性。

> Last-Modified: Sat, 09 Jun 2018 08:13:56 GMT 

第二次请求这个文件时，浏览器把If-Modified-Since发送给服务器，询问该时间之后文件是否被修改过。

> If-Modified-Since: Sat, 09 Jun 2018 08:13:56 GMT // 跟Last-Modified的值一样

**ETag & If-None-Match**

   ETag与If-None-Match是一对报文，属于http 1.1。

**ETag是一个文件的唯一标志符。**就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。

ETag机制类似于乐观锁机制，如果请求报文的ETag与服务器的不一致，则表示该资源已经被修改过来，需要发最新的内容给浏览器。

ETag也是首次请求的时候，服务器返回的:

ETag: "8F759D4F67D66A7244638AD249675BE2" // 长这样
    
If-None-Match也是浏览器发送到服务器验证，文件是否改变的:

If-None-Match: "8F759D4F67D66A7244638AD249675BE2" // 跟ETag的值一样
**Etag/lastModified过程如下:**

1. 客户端第一次向服务器发起请求,服务器将附加Last-Modified/ETag到所提供的资源上去
2. 当再一次请求资源,如果没有命中强缓存,在执行在验证时,将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。
3. 服务器检查该Last-Modified或ETag，并判断出该资源页面自上次客户端请求之后还未被修改，返回响应304和一个空的响应体。

**同时使用两个报文头:**
同时使用这两个报文头，两个都匹配才会命中弱缓存，否则将重新请求资源。

![HTTPç¼å­](F:\Code\github\浏览器\assets\005Y4rCogy1fs5437be2fj30r30g7jt4.jpg)

**Etag 主要为了解决 Last-Modified 无法解决的一些问题：**

1. 一些文件也许内容并不改变(仅仅改变的修改时间)，这个时候我们不希望文件重新加载。（Etag值会触发缓存，Last-Modified不会触发）
2. If-Modified-Since能检查到的粒度是秒级的，当修改非常频繁时，Last-Modified会触发缓存，而Etag的值不会触发，重新加载。
3. 某些服务器不能精确的得到文件的最后修改时间。

**用户操作行为与缓存**
F5刷新导致强缓存失效。

ctrl+F5强制刷新页面强缓存，弱缓存都会失效。

![å¾çåºèªç½ç"](F:\Code\github\浏览器\assets\005Y4rCogy1fs543w72mzj30dr04vglj.jpg)

